<!DOCTYPE html>

<!--[if lt IE 7]>
<html class="no-js ie lt-ie9 lt-ie8 lt-ie7" lang="en">
<![endif]-->
<!--[if IE 7]>
<html class="no-js ie lt-ie9 lt-ie8" lang="en">
<![endif]-->
<!--[if IE 8]>
<html class="no-js ie lt-ie9" lang="en">
<![endif]-->
<!--[if IE 9]>
<html class="no-js ie ie9" lang="en">
<![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
	<meta charset="utf-8">
  <title>donejs - Apis</title>
	<meta property="og:title" content="donejs - Apis">
	<meta property="og:description" content="DoneJS is comprised of many projects that are documented separately. This page contains overviews of each project and links to their official APIs. Application Infrastructure The blue boxes in the following architecture diagram represent modules provided by DoneJS.   StealJS - Module loader and build system. api. CanJS - Views, ViewModels, modeling part of Models, custom elements, routing. api can-query-logic Data service modelling. jQuery - DOM utilities. api done-ssr - Incremental server-side rendering for NodeJS. api done-autorender - Processes templates so they can be server-side rendered. api can-simple-dom - A lightweight virtual DOM. api  Tooling DoneJS provides many aspects of JavaScript application tooling, shown in the diagram below.   donejs-cli - The commands available to the donejs command line interface. api generator-donejs - Default generators are bundled with DoneJS. api QUnit - Default test assertion library. api FuncUnit - Functional test utilities. api Testee - Browser launcher and test reporter. api DocumentJS - Documentation engine. api">
  <meta property="og:image" content="https://www.bitovi.com/hubfs/open-source/os-donejs.jpg">
	<meta name="google-site-verification" content="-E1_on_BhUFqVXxNgtGgNYF5FIJojlOksLPK8zdeiL8" />
	<meta name="description" content="DoneJS is comprised of many projects that are documented separately. This page contains overviews of each project and links to their official APIs. Application Infrastructure The blue boxes in the following architecture diagram represent modules provided by DoneJS.   StealJS - Module loader and build system. api. CanJS - Views, ViewModels, modeling part of Models, custom elements, routing. api can-query-logic Data service modelling. jQuery - DOM utilities. api done-ssr - Incremental server-side rendering for NodeJS. api done-autorender - Processes templates so they can be server-side rendered. api can-simple-dom - A lightweight virtual DOM. api  Tooling DoneJS provides many aspects of JavaScript application tooling, shown in the diagram below.   donejs-cli - The commands available to the donejs command line interface. api generator-donejs - Default generators are bundled with DoneJS. api QUnit - Default test assertion library. api FuncUnit - Functional test utilities. api Testee - Browser launcher and test reporter. api DocumentJS - Documentation engine. api">
	<meta name="author" content="Bitovi - DoneJS">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <script type="application/ld+json">
		{
			"@context": "http://www.schema.org",
			"@type": "SoftwareSourceCode",
			"applicationCategory": "DeveloperApplication",
			"brand": "Bitovi",
			"category": "JavaScript Frameworks",
			"codeRepository": "https://github.com/donejs/donejs",
			"description": "DoneJS is comprised of many projects that are documented separately. This page contains overviews of each project and links to their official APIs. Application Infrastructure The blue boxes in the following architecture diagram represent modules provided by DoneJS.   StealJS - Module loader and build system. api. CanJS - Views, ViewModels, modeling part of Models, custom elements, routing. api can-query-logic Data service modelling. jQuery - DOM utilities. api done-ssr - Incremental server-side rendering for NodeJS. api done-autorender - Processes templates so they can be server-side rendered. api can-simple-dom - A lightweight virtual DOM. api  Tooling DoneJS provides many aspects of JavaScript application tooling, shown in the diagram below.   donejs-cli - The commands available to the donejs command line interface. api generator-donejs - Default generators are bundled with DoneJS. api QUnit - Default test assertion library. api FuncUnit - Functional test utilities. api Testee - Browser launcher and test reporter. api DocumentJS - Documentation engine. api",
			"image": "https://www.bitovi.com/hubfs/open-source/os-donejs.jpg",
			"license": "https://github.com/donejs/donejs/blob/master/license.md",
			"logo": "https://www.bitovi.com/hubfs/open-source/os-donejs.jpg",
			"name": "DoneJS - Apis",
			"programmingLanguage": "JavaScript"
		}
	</script>
	<link rel="apple-touch-icon" sizes="57x57" href="static/img/favicons/apple-touch-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="static/img/favicons/apple-touch-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="static/img/favicons/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="static/img/favicons/apple-touch-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="static/img/favicons/apple-touch-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="static/img/favicons/apple-touch-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="static/img/favicons/apple-touch-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="static/img/favicons/apple-touch-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="static/img/favicons/apple-touch-icon-180x180.png">
	<link rel="icon" type="image/png" href="static/img/favicons/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="static/img/favicons/android-chrome-192x192.png" sizes="192x192">
	<link rel="icon" type="image/png" href="static/img/favicons/favicon-96x96.png" sizes="96x96">
	<link rel="icon" type="image/png" href="static/img/favicons/favicon-16x16.png" sizes="16x16">
	
		<link rel="stylesheet" type="text/css" href="./static/bundles/bit-docs-site/static.css">
	
	<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">
</head>
<body class="docs Apis">
		<div id="greyOutUnderNav" style="display:none;"></div>
		<header>
			<nav class="navbar navbar-default navbar-fixed-top">
				<div class="container">
					<!-- Brand and toggle get grouped for betteor mobile display -->
					<div class="navbar-header">
						<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
							<span class="sr-only">Toggle navigation</span>
							<span class="mobile-menu-label">MENU</span>
							<span class="mobile-menu-close"></span>
						</button>
						<div class="logo-menu">
							<a class="brand" href="./index.html">DoneJS</a>
							<ul class="dropdown-menu hidden-xs">
								<li><a href="https://donejs.com" class="active">DoneJS</a></li>
								<li><a href="https://canjs.com">CanJS</a></li>
								<li><a href="https://stealjs.com">StealJS</a></li>
								<li><a href="https://jquerypp.com">jQuery++</a></li>
								<li><a href="https://funcunit.com">FuncUnit</a></li>
								<li><a href="https://documentjs.com">DocumentJS</a></li>
							</ul>
						</div>
					</div>
					<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
						<ul class="nav navbar-nav">
							<li ><a href="./index.html">Home</a></li>
							<li ><a href="./Features.html">Features</a></li>
							<li ><a href="./About.html">About</a></li>
							<li class="active"><a href="./Apis.html">Apis</a></li>

							<li class="guides-menu">
								<a href="./Guides.html">Guides</a>
								<ul class="dropdown-menu">
									<li><a href="./SettingUp.html">Setting Up</a></li>
									<li><a href="./Guide.html">Quick Start</a></li>
									<li><a href="./place-my-order.html">In-depth</a></li>
									<li><a href="./plugin.html">Creating a plugin</a></li>
									<li><a href="./generator.html">Creating a generator</a></li>
									<li><a href="./bitballs.html">Example App: Bitballs</a></li>
                  <li><a href="./ssr-react.html">Server rendering React</a></li>
									<li><a href="./migrate-1.html">Migrate to DoneJS 1</a></li>
                  <li><a href="./migrate-2.html">Migrate to DoneJS 2</a></li>
                  <li><a href="./migrate-3.html">Migrate to DoneJS 3</a></li>
                  <li><a href="./updating-deps.html">Updating Dependencies</a></li>
									<li><a href="./contributing.html">Contributing</a></li>
								</ul>
							</li>

							<li >
								<a href="./community.html">Community</a>
							</li>
						</ul>

						<ul class="nav navbar-nav navbar-right bitovi-menu">
							<li class="dropdown">
								<a href="https://www.bitovi.com" class="bitovi icon-bits">Bitovi</a>
								<ul class="dropdown-menu">
									<li><a href="https://www.bitovi.com/">Bitovi.com</a></li>
									<li><a href="https://www.bitovi.com/blog">Blog</a></li>
									<li><a href="https://www.bitovi.com/design">Design</a></li>
									<li><a href="https://www.bitovi.com/development">Development</a></li>
									<li><a href="https://www.bitovi.com/training">Training</a></li>
									<li><a href="https://www.bitovi.com/open-source">Open Source</a></li>
									<li><a href="https://www.bitovi.com/about">About</a></li>
									<li><a href="https://www.bitovi.com/contact">Contact Us</a></li>
								</ul>
							</li>
						</ul>
						<ul class="menu-lib-logos hidden-sm hidden-md hidden-lg">
							<li>
								<a href="#">
									<img class="logo-canjs" src="static/img/lib-logos/canjs_logo.svg" />
									<span class="logo-label">CanJS</span>
								</a>
							</li>
							<li>
								<a href="#">
									<img class="logo-stealjs" src="static/img/lib-logos/stealjs-logo.svg" />
									<span class="logo-label">StealJS</span>
								</a>
							</li>
							<li>
								<a href="#">
									<img class="logo-jqueryplus" src="static/img/lib-logos/jquery-plusplus-logo.svg" />
									<span class="logo-label">jQuery++</span>
								</a>
							</li>
							<li>
								<a href="#">
									<img class="logo-funcunit" src="static/img/lib-logos/funcunit-logo.svg" />
									<span class="logo-label">FuncUnit</span>
								</a>
							</li>
							<li>
								<a href="#">
									<img class="logo-docjs" src="static/img/lib-logos/documentjs-logo.svg" />
									<span class="logo-label">DocumentJS</span>
								</a>
							</li>
						</ul>

					</div>
				</div>
			</nav>
		</header>

	<div class="scroll-spy-title hidden-md hidden-lg">
    <span class="menu-indicator menus-closed"></span>
		<div id="scrollSpyCurrentH2" class="h2Only">Table of Contents</div>
		<div id="scrollSpyCurrentH3"></div>
	</div>
	

	
	<div class="container-fluid api">
		<div class="row">
	
		

		
		<article class="content docs col-xs-12 ">
		

			
			<section class="title">
				<div class="heading">
<h1>Apis</h1>
	<ul class="tags">
		<li>page</li>
	</ul>
	
	
</div>

<div class="sub-heading">
	
	
	<span class="inherits">&nbsp;</span>
</div>

<ul class="links">
	
	
	
</ul>
<br />

			</section>
			

      
      <section
        class="contents on-this-page-container"
        data-headings-container-selector=".content .comment"
        >
      </section>
      

			

			
			<section class="description">
				<p>DoneJS is comprised of many projects that are documented separately. This page contains overviews of each project and links to their official APIs.</p>
<h3>Application Infrastructure</h3>
<p>The blue boxes in the following architecture diagram represent modules provided by DoneJS.</p>
<object type="image/svg+xml" data="static/img/donejs-stack-app.svg"></object>
<ul>
<li><a href="#stealjs">StealJS</a> - Module loader and build system. <a href="https://stealjs.com/docs/index.html">api</a>.</li>
<li><a href="#canjs">CanJS</a> - Views, ViewModels, modeling part of Models, custom elements, routing. <a href="https://canjs.com/doc/api.html">api</a></li>
<li><a href="https://canjs.com/doc/can-query-logic.html">can-query-logic</a> Data service modelling.</li>
<li><a href="#jquery">jQuery</a> - DOM utilities. <a href="https://jquery.com/">api</a></li>
<li><a href="#done-ssr">done-ssr</a> - Incremental server-side rendering for NodeJS. <a href="https://github.com/donejs/done-ssr">api</a></li>
<li><a href="#done-autorender">done-autorender</a> - Processes templates so they can be server-side rendered. <a href="https://github.com/donejs/autorender#use">api</a></li>
<li><a href="#can-simple-dom">can-simple-dom</a> - A lightweight virtual DOM. <a href="https://github.com/canjs/can-simple-dom">api</a></li>
</ul>
<h3>Tooling</h3>
<p>DoneJS provides many aspects of JavaScript application tooling, shown in the diagram below.</p>
<object type="image/svg+xml" data="static/img/donejs-stack-tooling.svg"></object>
<ul>
<li><a href="#cli-and-generators">donejs-cli</a> - The commands available to the donejs command line interface. <a href="https://github.com/donejs/cli">api</a></li>
<li><a href="#cli-and-generators">generator-donejs</a> - Default generators are bundled with DoneJS. <a href="https://github.com/donejs/generator-donejs/">api</a></li>
<li><a href="#qunit">QUnit</a> - Default test assertion library. <a href="https://qunitjs.com/">api</a></li>
<li><a href="#funcunit">FuncUnit</a> - Functional test utilities. <a href="https://funcunit.com/">api</a></li>
<li><a href="#testee">Testee</a> - Browser launcher and test reporter. <a href="https://github.com/bitovi/testee">api</a></li>
<li><a href="#documentjs">DocumentJS</a> - Documentation engine. <a href="https://documentjs.com/">api</a></li>
</ul>

			</section>
			

			
				
			

			


			
			<section class="comment">
				<h2>Application flow overview</h2>
<p>Lets talk about how the typical behavior of a DoneJS application works.  We'll use
the chat application as an example in development.  We'll cover what happens when:</p>
<ul>
<li>A user navigates their browser from a different domain to <code>https://chat.donejs.com/</code></li>
<li>A user navigates from <code>https://chat.donejs.com/</code> to another <code>https://chat.donejs.com/chat</code>.</li>
</ul>
<h3>First page load</h3>
<ol>
<li><p>An http request for <code>https://chat.donejs.com/</code> is sent to a node server. The node server is configured,
in this case with express, to use <a href="#done-ssr">done-ssr-middleware</a> to render a DoneJS application:</p>
<pre><code class="language-js">var ssr = require('done-ssr-middleware');

app.use('/', ssr());
</code></pre></li>
<li><p><a href="#done-ssr">done-ssr</a> uses <a href="#stealjs">steal</a> to load the application's main module which results in loading the
entire application. Loading the application only happens once for all page requests.</p>
<p>A DoneJS's main module is specified where all configuration of a DoneJS application happens, its <code>package.json</code>.
The main module is usually a <a href="#canstache">can-stache</a> template processed with the <a href="#done-autorender">done-autorender</a>
plugin. The module name is specified like: <code>index.stache!done-autorender</code>. <code>index.stache</code> might look like:</p>
<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;My Site&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;can-import from=&quot;styles.less&quot;/&gt;
  &lt;can-import from=&quot;donejs-chat/app&quot; export-as=&quot;viewModel&quot; /&gt;

  {{pageComponent}}

  &lt;script src=&quot;node_modules/steal/steal.js&quot; main=&quot;index.stache!done-autorender&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>The <a href="#done-autorender">done-autorender</a> plugin, in NodeJS, exports this template so it can be rendered.</p></li>
<li><p>Once <a href="#done-ssr">done-ssr</a> has the <a href="#done-autorender">done-autorender</a>'s <code>template</code> and <code>viewModel</code> export it:</p>
<ol>
<li>Creates a new instance of the viewModel, setting properties on it
using <a href="#canroute">can-route</a>'s routing rules.</li>
<li>Creates a new <a href="#can-simple-dom">virtual DOM</a> instance.</li>
<li>Renders the <a href="#canstache">template</a> with the <code>viewModel</code> into the <code>virtual DOM</code> instance.</li>
<li><a href="#done-autorender">done-autorender</a> templates waits for all promises to complete
before providing a final result.  Once the template is finished rendering, <a href="#done-ssr">done-ssr</a> converts it to a
string and sends it back to the browser.</li>
<li>The browser downloads the page's HTML, which includes a <code>&lt;script&gt;</code> tag that points to <a href="#stealjs">steal</a>.</li>
</ol>
<pre><code class="language-html">&lt;script src=&quot;node_modules/steal/steal.js&quot; main&gt;&lt;/script&gt;
</code></pre>
<p>In development, this loads <code>steal.js</code> which then loads <code>index.stache</code> and processes it with
the <code>done-autorender</code>.</p></li>
<li><p>In the browser, <code>done-autorender</code>:</p>
<ol>
<li>Creates a new instance of the <a href="#canmap">viewModel</a>, setting properties on it
using <a href="#canroute">can-route</a>'s routing rules.</li>
<li>Renders the <a href="#canstache">template</a> with the <code>viewModel</code> into a document fragment.</li>
<li>Once all asynchronous activity has completed, it replaces the document with the rendered result.</li>
</ol></li>
</ol>
<h3>Pushstate change</h3>
<ol>
<li><p>A pushstate is triggered by user action, usually by clicking a link. <a href="#canroute">can-route</a>'s routing rules determines the properties set on the application <a href="#canmap">viewModel</a>.</p>
<pre><code class="language-js">route.register('{page}', { page: 'home' });
</code></pre></li>
<li><p><a href="#done-autorender">done-autorender</a> previously bound the AppViewModel to <a href="#canroute">can-route</a> which causes any change in the route to be reflected in the ViewModel instance.</p></li>
<li><p>Live binding causes the initial template to reflect in the change in route. If the new route is <code>/chat</code> it will cause the <code>page</code> to be <strong>chat</strong>:</p>
<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;My Site&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;can-import from=&quot;styles.less&quot;/&gt;
  &lt;can-import from=&quot;donejs-chat/app&quot; export-as=&quot;viewModel&quot; /&gt;

  {{pageComponent}}

  &lt;script src=&quot;node_modules/steal/steal.js&quot; main&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></li>
</ol>
<h2>CLI and Generators</h2>
<p>After installing DoneJS globally with <code>npm install donejs -g</code> you will have the <code>donejs</code> command available on the command line. It lets you initialize a new application and - when navigating within a DoneJS project - run scripts provided locally by your application. Within your application folder the <code>donejs</code> command is a convenience wrapper for the functionality described below and you can also get a list of all commands by running</p>
<pre><code>donejs help
</code></pre>
<h3>npm scripts</h3>
<p><a href="https://docs.npmjs.com/misc/scripts">npm scripts</a> are defined in the <code>scripts</code> section of your applications <code>package.json</code>. There are some standard scripts that every Node application uses (like <code>npm start</code> or <code>npm test</code> - both of which are already set up for you) and you can add your own which is what DoneJS does with commands like <code>npm run develop</code> or <code>npm run build</code>.
The <code>donejs</code> command makes running those commands easier by allowing you to run them like <code>donejs start</code>, <code>donejs develop</code> or <code>donejs build</code></p>
<h3>Generators</h3>
<p><code>donejs add</code> lets you run the <a href="http://yeoman.io/">Yeoman</a> generators provided by <a href="https://github.com/donejs/generator-donejs/">generator-donejs</a>. Currently the following generators are available:</p>
<ul>
<li><code>donejs add app [folder]</code> which will initialize a new application (optionally within the given folder)</li>
<li><code>donejs add component &lt;modulename&gt; &lt;tagname&gt;</code> to create a new can-component</li>
<li><code>donejs add supermodel &lt;modulename&gt;</code> to generate a new model</li>
<li><code>donejs add plugin [folder]</code> which will initialize a new plugin project</li>
<li><code>donejs add generator [folder]</code> which will initialize a new generator project</li>
</ul>
<h3>Third-party generators</h3>
<p>If <code>donejs add</code> can’t find a built-in generator, e.g. when running <code>donejs add mygenerator</code>, DoneJS will try to install the <code>donejs-mygenerator</code> package from npm and run the Yeoman generators it provides. This is how we can enable a desktop application build of the application by simply running:</p>
<pre><code>donejs add electron
</code></pre>
<p>Which will install the <a href="https://github.com/donejs/donejs-electron">donejs-electron</a> package and then run its generator, which initializes everything you need. This also works for adding a mobile application build using <a href="https://github.com/donejs/donejs-cordova">donejs-cordova</a> like this:</p>
<pre><code>donejs add cordova
</code></pre>
<p>This way you can use DoneJS’s growing list of plugins and generators without having to add anything to your application that you don't use.</p>
<h2>StealJS</h2>
<p>The base of any good JavaScript application is its dependency management system.<br />
DoneJS uses <a href="https://stealjs.com/">StealJS</a> which
itself  is split into two sub-projects:</p>
<ul>
<li><code>steal</code> - loads CommonJS, ES6, and AMD modules. It can also load styles, templates and more.</li>
<li><code>steal-tools</code> - builds your application's modules for production and also provides hot-module-swapping.</li>
</ul>
<h3>steal</h3>
<p>To use <a href="https://stealjs.com/docs/steal.html">steal</a>, simply add a script tag to <code>steal.js</code>
in an HTML page or in a <a href="#done-autorender">done-autorender</a> <code>template</code> and
point the <code>main</code> attribute to a module to load like:</p>
<pre><code class="language-html">&lt;script src=&quot;../../node_modules/steal/steal.js&quot; main=&quot;my-app/my-module&quot;&gt;&lt;/script&gt;
</code></pre>
<p>Using the default DoneJS <a href="https://stealjs.com/docs/npm.html#configuration">system.directories.lib</a> configuration, this will load
<code>my-app/src/my-module.js</code>.  From there, use CommonJS, ES6, or AMD to load your modules:</p>
<pre><code class="language-js">// my-app/src/my-module.js
import $ from &quot;jquery&quot;;
import &quot;./styles.css&quot;;

$('body')
</code></pre>
<p>If an <code>import</code>, <code>require</code> or <code>define</code> module reference ends with <code>&quot;/&quot;</code>, is a shorthand
for importing a module in the modlet format. The moduleName imported is the same
as the module reference, but with the last folder name added again.</p>
<p>Some examples:</p>
<pre><code class="language-js">// in components/person module.
import &quot;can-component&quot;; //imports &quot;can-component&quot;;
import &quot;./edit/&quot;; // imports &quot;components/person/edit/edit&quot;;
</code></pre>
<p>Configure <a href="https://stealjs.com/docs/steal.html">steal</a>'s behavior in your <code>package.json</code> in the <code>steal</code> object like:</p>
<pre><code class="language-js">// package.json
{
  &quot;main&quot;: &quot;index.stache!done-autorender&quot;,
  ...
  &quot;steal&quot;: {
    &quot;meta&quot;: {
      &quot;ui/core&quot;: {
        &quot;deps&quot;: [
          &quot;jquery&quot;,
          &quot;theme/core.css&quot;,
          &quot;theme/theme.css&quot;
        ]
      }
    }
  }
}
</code></pre>
<h3>steal-tools</h3>
<p>In DoneJS applications, <a href="https://stealjs.com/docs/steal-tools.html">steal-tools</a> is primarily used to:</p>
<ul>
<li><a href="https://stealjs.com/docs/steal-tools.build.html">build</a> and minify your application to production-ready bundles.</li>
<li>add <a href="https://stealjs.com/docs/steal-tools.cmd.live-reload.html">hot module swapping</a></li>
</ul>
<p>It can also be used to <a href="https://stealjs.com/docs/steal-tools.export.html">export</a> your
modules to different formats.</p>
<p>DoneJS comes with a <code>build.js</code> script that call's steal-tools' <a href="https://stealjs.com/docs/steal-tools.build.html">build</a>:</p>
<pre><code class="language-js">//build.js
var stealTools = require(&quot;steal-tools&quot;);

var buildPromise = stealTools.build({
  config: __dirname + &quot;/package.json!npm&quot;
}, {
  bundleAssets: true
});
</code></pre>
<p>This is already configured to run with:</p>
<pre><code>&gt; donejs build
</code></pre>
<p>But you could also run it with:</p>
<pre><code>&gt; node build.js
</code></pre>
<p>Hot module swapping is done with <a href="https://stealjs.com/docs/steal-tools.cmd.live-reload.html">live-reload</a> which
is bundled within steal-tools.</p>
<p>By default <code>donejs develop</code> starts the live-reload server.  However, you could start one
yourself with:</p>
<pre><code>&gt; steal-tools live-reload
</code></pre>
<h2>CanJS</h2>
<p>CanJS provides:</p>
<ul>
<li><strong>observables</strong> with <a href="#canmap">can-map</a>, <a href="#canlist">can-list</a>, and <a href="#cancompute">can-compute</a>.</li>
<li><strong>one-way and two-way binding templates</strong> with <a href="#canstache">can-stache</a> and <a href="#canviewbindings">can-stache-bindings</a>.</li>
<li><strong>custom elements</strong> with <a href="#cancomponent">can-component</a>.</li>
<li><strong>routing</strong> with <a href="#canroute">can-route</a>.</li>
</ul>
<p>Observables act as the <code>ViewModel</code> and part of the <code>Model</code>.</p>
<p>One-way and two-way binding templates act as the <code>View</code>.</p>
<p><a href="#cancomponent">can-component</a> is used to combine <code>View</code> and <code>ViewModel</code> into
easy to instantiate and assemble custom elements.</p>
<p>Checkout the following quick examples of their use:</p>
<p><strong>observables</strong>:</p>
<pre><code class="language-js">// Observable objects:
var person = new DefineMap({first: &quot;Justin&quot;, last: &quot;Meyer&quot;});

// Observable arrays:
var hobbies =  new DefineList([&quot;basketball&quot;, &quot;hip-hop dancing&quot;]);

// Observable single values:
var age = compute(33);

// Observable computed values:
var info = compute(function(){
  return person.first + &quot; &quot; + person.last + &quot; is &quot; +
    age() + &quot; and likes &quot; + hobbies.join(&quot;,&quot;) + &quot;.&quot;;
});

// Get the compute's value
info() //-&gt; Justin Meyer is 33 and likes\
       //   basketball, hip-hop dancing.

// Listen to changes in the compute
info.bind(&quot;change&quot;, function(ev, newValue){
  newValue //-&gt; Justin Meyer is 33 and likes\
           //   basketball, hip-hop dancing.
});

hobbies.pop(); // causes `change` event above
</code></pre>
<p><strong>one and two-way binding templates</strong>:</p>
<pre><code class="language-js">// Programmatically create a template
// `value:bind` cross binds the input's value
// to `first` in the scope.
var template = stache(&quot;&lt;h1&gt;{{first}}&lt;/h1&gt;&quot;+
    &quot;&lt;input value:bind='first'/&gt;&quot;);

// Create observable data for the template
var person = new DefineMap({first: &quot;Payal&quot;});

// Render the template with data
var frag = template(person);

// Add the result to the document
document.body.appendChild(frag);

// Document shows rendered result
document.body //-&gt; &lt;h1&gt;Payal&lt;/h1&gt;&lt;input value='Payal'/&gt;

// ... User changes the input's value to &quot;Ramiya&quot; ...

// Document is updated with changes
document.body //-&gt; &lt;h1&gt;Ramiya&lt;/h1&gt;&lt;input value='Ramiya'/&gt;
</code></pre>
<p><strong>custom elements</strong>:</p>
<pre><code class="language-js">// Create a custom `can-define/map/map` constructor function
// with a helper function.
var PersonEditViewModel = DefineMap.extend({
  first: &quot;string&quot;,
  last: &quot;string&quot;,
  fullName: function(){
    return this.first + &quot; &quot; + this.last;
  }
});

// Create a template that will be rendered within
// `&lt;person-edit&gt;` elements.
var template = stache(`
  Update {{fullName}}:
    &lt;input value:bind='first'&gt;
    &lt;input value:bind='last'&gt;
`);

// Create the `&lt;person-edit&gt;` element with the specified
// viewModel and template (view).
Component.extend({
  tag: &quot;person-edit&quot;,
  ViewModel: PersonEditViewModel,
  view: view
});

// Use that custom element within another template.
// `first.bind` cross binds `&lt;person-edit&gt;`'s
// `first` property to `firstName` in the scope.
var parentTemplate = stache(`
  &lt;h1&gt;{{firstName}} {{lastName}}&lt;/h1&gt;
  &lt;person-edit first:bind='firstName' last:bind='lastName'&gt;
`);

// Render the parent template with some data:
var frag = parentTemplate(new DefineMap({
  firstName: &quot;Brian&quot;,
  lastName: &quot;Moschel&quot;
}));

document.body.appendChild(frag);
</code></pre>
<h3>can-define/map/map</h3>
<p><a href="https://canjs.com/doc/can-define.html">can-define</a> is used to create observable
JavaScript Object-like objects.  Create an instance of the
base can-define/map/map like:</p>
<pre><code class="language-js">var person = new DefineMap({first: &quot;Justin&quot;, last: &quot;Meyer&quot;});
</code></pre>
<p>Read or write a <code>map</code>'s properties:</p>
<pre><code class="language-js">person.first //-&gt; Justin

person.first = &quot;Ramiya&quot;;
person.get() //-&gt; {first: &quot;Ramiya&quot;, last: &quot;Meyer&quot;}

person.first = &quot;Brian&quot;;
person.last = &quot;Moschel&quot;;
person.get() //-&gt; {first: &quot;Brian&quot;, last: &quot;Moschel&quot;}
</code></pre>
<p>Bind to changes in a person's properties with <a href="https://canjs.com/doc/can-define/map/map.prototype.on.html">.on</a>:</p>
<pre><code class="language-js">person.on(&quot;first&quot;, function(ev, newValue, oldValue){
  newValue //-&gt; &quot;Laura&quot;
  oldvalue //-&gt; &quot;Brian&quot;
});

// changing `first` causes the function
// call above.
person.first = &quot;Laura&quot;;
</code></pre>
<p>Extend a <code>DefineMap</code> to create a new constructor function.  This is
very useful for creating Models and View Models:</p>
<pre><code class="language-js">// pass extend an object of prototype values
var Person = DefineMap.extend({
  first: &quot;string&quot;,
  last: &quot;string&quot;,
  fullName: function(){
    person.first + &quot; &quot; + person.last;
  }
})

var me = new Person({first: &quot;Kathrine&quot;, last: &quot;Iannuzzi&quot;});
me.fullName() //-&gt; &quot;Kathrine Iannuzzi&quot;
</code></pre>
<p>The <a href="https://canjs.com/doc/can-define.html">can-define</a> allows
you to control the behavior of attributes.  You can define
<a href="https://canjs.com/doc/can-define.types.value.html">default values</a>,
<a href="https://canjs.com/doc/can-define.types.get.html">getters</a>,
<a href="https://canjs.com/doc/can-define.types.set.html">setters</a>, and
<a href="https://canjs.com/doc/can-define.types.type.html">type</a> converters.</p>
<pre><code class="language-js">var Todo = DefineMap.extend({
  percentComplete: {
    default: 0.1,
    type: &quot;number&quot;,
    get: function(value){
      return &quot;&quot;+value+&quot;%&quot;
    },
    set: function(newValue){
      return newValue*100;
    }
  }
});

var todo = new Todo();
todo.percentComplete //-&gt; 10%
</code></pre>
<p>You can even describe asynchronous behavior which is critical for working
with service data:</p>
<pre><code class="language-js">var Todo = DefineMap.extend({
  ownerId: &quot;number&quot;,
  owner: {
    get: function(lastSetValue, resolve){
      User.get({id: this.ownerId}).then(resolve);
    }
  }
});

todo = new Todo({ownerId: 5});

// async values only become valid when bound
// this isn't a problem because templates usually bind for you
todo.on(&quot;owner&quot;, function(ev, owner){
  owner //-&gt; a User instance
});
</code></pre>
<h3>can-define/list/list</h3>
<p><a href="https://canjs.com/doc/can-define/list/list.html">can-define/list/list</a> is used to create observable
JavaScript Array-like objects.  Create an instance of the
base <code>DefineList</code> like:</p>
<pre><code class="language-js">var hobbies = new DefineList([&quot;basketball&quot;,&quot;dancing&quot;]);
</code></pre>
<p>Read and write items from the list or to read the length:</p>
<pre><code class="language-js">for(var i = 0, len = hobbies.length; i &lt; len; i++){
  var hobby = hobbies.get(i);
}
hobbies.set(1, &quot;hip hop dancing&quot;);
hobbies.get() //-&gt; [&quot;basketball&quot;, &quot;dancing&quot;]
</code></pre>
<p>Use array methods like <a href="https://canjs.com/doc/can-define/list/list.prototype.push.html">.push</a>, <a href="https://canjs.com/doc/can-define/list/list.prototype.pop.html">.pop</a>, and <a href="https://canjs.com/doc/can-define/list/list.prototype.splice.html">.splice</a> to modify the array:</p>
<pre><code class="language-js">hobbies.pop();

hobbies.generated() //-&gt; [&quot;basketball&quot;];

hobbies.push(&quot;football&quot;);

hobbies //-&gt; DefineList[&quot;basketball&quot;,&quot;football&quot;]
</code></pre>
<p>Use <a href="https://canjs.com/doc/can-define/list/list.prototype.forEach.html">.forEach</a>, <a href="https://canjs.com/doc/can-define/list/list.prototype.map.html">.map</a>, or <a href="https://canjs.com/doc/can-define/list/list.prototype.filter.html">.filter</a> to loop through the array.  All
these methods return a <code>DefineList</code></p>
<pre><code class="language-js">var intramurals = hobbies.map(function(hobby){
  return &quot;intramural &quot;+hobby;
})
intramurals //-&gt; DefineList[&quot;intramural basketball&quot;,
                          &quot;intramural football&quot;]
</code></pre>
<p>Listen to when a list changes by binding on <code>add</code> or <code>remove</code> or <code>length</code>
events.</p>
<pre><code class="language-js">hobbies.on(&quot;add&quot;, function(ev, newHobbies, index){
    console.log(&quot;added&quot;, newHobbies,&quot;at&quot;, index);
  })
  .on(&quot;remove&quot;, function(ev, removedHobbies, index){
    console.log(&quot;removed&quot;, newHobbies,&quot;at&quot;, index);
  })
  .on(&quot;length&quot;, function(ev, newVal, oldVal){
    console.log(&quot;length is&quot;, newVal);
  });

hobbies.splice(1,1,&quot;pumpkin carving&quot;,&quot;gardening&quot;);
  // console.logs:
  //     removed [football] 1
  //     added [&quot;pumpkin carving&quot;,&quot;gardening&quot;] 1
  //     length is 3
</code></pre>
<p>By default, if you initialize a list with plain JavaScript objects,
those objects are converted to a <code>DefineMap</code>:</p>
<pre><code class="language-js">var people = new DefineList([
  {first: &quot;Justin&quot;, last: &quot;Meyer&quot;, age: 72},
  {first: &quot;David&quot;, last: &quot;Luecke&quot;, age: 20},
  {first: &quot;Matthew&quot;, last: &quot;Phillips&quot;, age: 30}
]);

people.get(0).first //-&gt; Justin
</code></pre>
<p>You can create your own custom <code>DefineList</code> constructor functions
by extending <code>DefineList</code>:</p>
<pre><code class="language-js">var People = DefineList.extend({
  seniors: function(){
    return this.filter(function(person){
      return person.age &gt;= 65
    });
  }
});

var people = new People([
  {first: &quot;Justin&quot;, last: &quot;Meyer&quot;, age: 72},
  {first: &quot;David&quot;, last: &quot;Luecke&quot;, age: 20},
  {first: &quot;Matthew&quot;, last: &quot;Phillips&quot;, age: 30}
]);

people.seniors() //-&gt; People[{Justin}]
</code></pre>
<p>When extending <code>DefineList</code> you can specify the default <code>Map</code> type
that's created when plain JS objects are added to the list:</p>
<pre><code class="language-js">var Person = can.Map.extend({
  fullName: function(){
    person.first + &quot; &quot; + person.last;
  }
});

var People = DefineList.extend({
  &quot;#&quot;: Person
},{
  seniors: function(){
    return this.filter(function(person){
      return person.age &gt;= 65
    });
  }
});

var people = new People([
  {first: &quot;Justin&quot;, last: &quot;Meyer&quot;, age: 72},
  {first: &quot;David&quot;, last: &quot;Luecke&quot;, age: 20},
  {first: &quot;Matthew&quot;, last: &quot;Phillips&quot;, age: 30}
]);

people.get(0).fullName() //-&gt; &quot;Justin Meyer&quot;
</code></pre>
<h3>can-compute</h3>
<p><a href="https://canjs.com/doc/can-compute.html">can-compute</a> isn't used
directly much anymore. However, it's used heavily in <a href="#candefine">can-define</a>
<a href="https://canjs.com/doc/can-define.types.get.html">getters</a> and live binding
so it's worth understanding the basics.</p>
<p><code>can-compute</code> allows you to define single observable values like:</p>
<pre><code class="language-js">var age = compute(33);
</code></pre>
<p>or derived values like:</p>
<pre><code class="language-js">var person = new DefineMap({first: &quot;Justin&quot;, last: &quot;Meyer&quot;}),
    hobbies =  new DefineList([&quot;basketball&quot;, &quot;hip-hop dancing&quot;]);

var info = compute(function(){
  return person.first + &quot; &quot; + person.last + &quot; is &quot; +
    age() + &quot; and likes &quot; + hobbies.join(&quot;,&quot;) + &quot;.&quot;;
});
</code></pre>
<p>Read a compute by calling it like a function:</p>
<pre><code class="language-js">info() //-&gt; &quot;Justin Meyer is 33 and likes\
       //    basketball, hip-hop dancing.&quot;
</code></pre>
<p>Listen to a compute by binding on its <code>change</code> event:</p>
<pre><code class="language-js">info.on(&quot;change&quot;, function(ev, newVal, oldVal){
  console.log(&quot;IS:\n&quot;,newVal,&quot;\nWAS:\n&quot;, oldVal);
})
</code></pre>
<p>Internally, <code>on</code> runs the compute function, identifying what observable
values it reads, and listening to them.  It caches the return result so that
reading the compute again like <code>info()</code> just returns the cached result.</p>
<p>When any of the read observables change, it updates the cached value,
and calls back any event handlers:</p>
<pre><code class="language-js">person.first = &quot;Brian&quot;;
person.last = &quot;Moschel&quot;;

//  console.logs:
//  IS:
//  Brian Moschel is 33 and likes basketball, hip-hop dancing.
//  WAS:
//  Justin Meyer is 33 and likes basketball, hip-hop dancing.
</code></pre>
<h3>can-stache</h3>
<p><a href="https://canjs.com/doc/can-stache.html">can-stache</a> is a Handlebars and
Mustache compliant live-binding templating language.</p>
<p>Create a template programmatically with <code>can-stache</code> like:</p>
<pre><code class="language-js">var template = stache(&quot;&lt;h1&gt;{{first}} {{last}}&lt;/h1&gt;&quot;);
</code></pre>
<p><code>template</code> is a <strong>renderer</strong> function that, when called with observable data,
returns a <a href="https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment">DocumentFragment</a> that is updated when the observable data changes.</p>
<p>Add those fragments to the page to see the result:</p>
<pre><code class="language-js">var person = new DefineMap({first: &quot;Brian&quot;, last: &quot;Moschel&quot;})

var frag = template(person);

document.body.appendChild(frag);

document.body //-&gt; &lt;h1&gt;Brian Moschel&lt;/h1&gt;

person.first = &quot;Ramiya&quot;;
person.last = &quot;Meyer&quot;;

document.body //-&gt; &lt;h1&gt;Ramiya Meyer&lt;/h1&gt;
</code></pre>
<p>In a DoneJS application, templates are used primarily as part of
a <a href="#cancomponent">can-component</a> or as the <a href="#done-autorender">done-autorender</a>ed main template.</p>
<p>When used in a <a href="#cancomponent">can-component</a>, the templates are often put in their own file. For
example, a <code>person_edit.js</code> component file might have a <code>person_edit.stache</code> file like:</p>
<pre><code class="language-js">// person_edit.stache
Update {{fullName}}:
&lt;input value:bind='first'/&gt;
&lt;input value:bind='last'/&gt;
</code></pre>
<p>This template's <strong>renderer</strong> function is imported in <code>person_edit.js</code> like:</p>
<pre><code class="language-js">// person_edit.js
import template from &quot;./person_edit.stache&quot;;
import Component from &quot;can-component&quot;;

Component.extend({
  tag: &quot;person-edit&quot;,
  template: template
});
</code></pre>
<p><code>can-stache</code> template behavior is controlled by what's
within magic tags like <code>{{ }}</code>. There are different tag types, lots of
helper functions, and different ways to call methods and functions.</p>
<p>There's too much to cover so we will highlight the important APIs.</p>
<p>The different tag types:</p>
<ul>
<li><p><a href="https://canjs.com/doc/can-stache.tags.escaped.html">{{key}}</a> -
inserts an escaped value.</p>
<pre><code class="language-js">stache(&quot;{{key}}&quot;)({key: &quot;&lt;b&gt;Foo&lt;/b&gt;&quot;}) //-&gt; `&amp;lt;b&amp;gt;Foo&amp;lt;/b&amp;gt;`
</code></pre></li>
<li><p><a href="https://canjs.com/doc/can-stache.tags.unescaped.html">{{{key}}}</a> -
inserts an unescaped value.</p>
<pre><code class="language-js">stache(&quot;{{key}}&quot;)({key: &quot;&lt;b&gt;Foo&lt;/b&gt;&quot;}) //-&gt; `&lt;b&gt;Foo&lt;/b&gt;`
</code></pre></li>
<li><p><a href="https://canjs.com/doc/can-stache.tags.section.html">{{#key}} ... {{/key}}</a> -
renders a subsection depending on the value of the key.</p>
<pre><code class="language-js">// boolean values render the subsection or its inverse
stache(&quot;{{#key}}A{{/key}}&quot;)({key: true}) //-&gt; `A`
stache(&quot;{{#key}}A{{/key}}&quot;)({key: false}) //-&gt; ``
stache(&quot;{{#key}}A{{else}}B{{/key}}&quot;)({key: false}) //-&gt; `B`

// iterative values render the subsection for each value
stache(&quot;{{#key}}A{{/key}}&quot;)({key: [null,0]}) //-&gt; `AA`
stache(&quot;{{#key}}A{{/key}}&quot;)({key: []}) //-&gt; ``

</code></pre>
<p>The subsection is rendered with the <code>key</code> value as the top of the <a href="https://canjs.com/doc/can-view-scope.html">scope</a>:</p>
<pre><code class="language-js">stache(&quot;{{#key}}{{child}}{{/key}}&quot;)({key: {child:&quot;C&quot;}}) //-&gt;`C`
</code></pre></li>
<li><p><a href="https://canjs.com/doc/can-stache.tags.inverse.html">{{^key}} ... {{/key}}</a> -
opposite of <code>{{#key}}</code>.</p>
<pre><code class="language-js">stache(&quot;{{^key}}A{{/key}}&quot;)({key: true}) //-&gt; ``
stache(&quot;{{^key}}A{{/key}}&quot;)({key: false}) //-&gt; `A`
stache(&quot;{{^key}}A{{/key}}&quot;)({key: [null,0]}) //-&gt; ``

stache(&quot;{{^key}}A{{else}}B{{/key}}&quot;)({key: false}) //-&gt; `B`
</code></pre></li>
</ul>
<p>The following are stache's most commonly used helpers:</p>
<ul>
<li><p><a href="https://canjs.com/doc/can-stache.helpers.if.html">{{#if expr}} .. {{/if}}</a> - renders the subsection if the expr is truthy.</p>
<pre><code class="language-js">stache(&quot;{{#if key}}A{{/if}}&quot;)({key: true}) //-&gt; `A`
stache(&quot;{{#if key}}A{{/if}}&quot;)({key: false}) //-&gt; ``

stache(&quot;{{#if key}}A{{else}}B{{/if}}&quot;)({key: false}) //-&gt; `B`
</code></pre></li>
<li><p><a href="https://canjs.com/doc/can-stache.helpers.is.html">{{#is expr1 expr2}} ... {{/is}}</a> - compares two expressions and renders a subsection depending on the result.</p>
<pre><code class="language-js">stache(&quot;{{#is page 'A'}}A{{/is}}&quot;)({page: 'A'}) //-&gt; `A`
stache(&quot;{{#is page 'A'}}A{{/is}}&quot;)({page: 'B'}) //-&gt; ``

stache(&quot;{{#is page 'A'}}A{{else}}C{{/is}}&quot;)({page: 'C'}) //-&gt; `B`
</code></pre></li>
<li><p><a href="https://canjs.com/doc/can-stache.helpers.each.html">{{#each key}} ... {{/each}}</a> - renders a subsection for each item in a key's value.</p>
<pre><code class="language-js">stache('{{#each hobbies}}&lt;p&gt;{{.}}&lt;/p&gt;{{/each}}')(['Hockey', 'Hiking']) //-&gt; `&lt;p&gt;Hockey&lt;/p&gt;&lt;p&gt;Hiking&lt;/p&gt;`
</code></pre>
<p>If the value of a key is a <a href="#section=section_definelist">DefineList</a> only the minimum amount of DOM updates occur when the list changes.</p></li>
<li><p><a href="https://canjs.com/doc/can-stache/helpers/route.html">{{routeUrl hashes}}</a> - generates a url using <a href="#canroute">can-route</a> for the provided hashes.</p>
<pre><code class="language-js">stache(&quot;&lt;a href=&quot;{{routeUrl page='details' id='23'}}&quot;&gt;{{name}}&lt;/a&gt;&quot;)({name: 'Item 23'}) //-&gt; `&lt;a href=&quot;#!&amp;page=details&amp;id=23&quot;&gt;Item 23&lt;/a&gt;`
</code></pre></li>
</ul>
<p><a href="https://canjs.com/doc/can-stache.expressions.html#Callexpressions">Call methods</a> in your scope like: <code>{{method(value)}}</code></p>
<pre><code class="language-js">stache('&lt;p&gt;10 {{pluralize(&quot;Baloon&quot; 10)}}&lt;/p&gt;')({
  pluralize: function(subject, howMany) {
    if(howMany &gt; 1) {
      subject += 's';
    }
    return subject;
  }
}); //-&gt; &quot;&lt;p&gt;10 Baloons&lt;/p&gt;&quot;
</code></pre>
<h3>can-stache-bindings</h3>
<p><code>can-stache-bindings</code> allows you to bind to viewModel or DOM events and create one-way or two-way bindings on element's properties/attributes, can-component viewModels and <code>can-stache</code>'s scope.</p>
<p>Create a one-way binding from the parent scope to a child's properties/attributes or viewModel:</p>
<ul>
<li><a href="https://canjs.com/doc/can-stache-bindings.toChild.html">childProp:from=&quot;value&quot;</a> - One-way bind <code>name</code> in the scope to <code>userName</code> property on the viewModel or the <code>value</code> attribute on the <code>input</code> element.</li>
</ul>
<pre><code class="language-html">  &lt;my-component userName:from=&quot;name&quot;&gt;&lt;/my-component&gt;

  &lt;input value:from=&quot;name&quot; type=&quot;text&quot;&gt;
</code></pre>
<p>Create a one-way binding from the child's properties/attributes or viewModel to the parent scope:</p>
<ul>
<li><p><a href="https://canjs.com/doc/can-stache-bindings.toParent.html">childProp:to=&quot;name&quot;</a> - One-way bind the value of <code>userName</code> property on the viewModel or the <code>value</code> attribute on the <code>input</code> element to the <code>name</code> property in the parent scope.</p>
<pre><code class="language-html">&lt;my-component userName:to=&quot;name&quot;&gt;&lt;/my-component&gt;

&lt;input value:to=&quot;name&quot; type=&quot;text&quot;&gt;
</code></pre></li>
</ul>
<p>Create two-way bindings between the parent scope and the child's viewModel or property/attributes:</p>
<ul>
<li><p><a href="https://canjs.com/doc/can-stache-bindings.twoWay.html">propName:bind=&quot;value&quot;</a> - Two-way bind the value of <code>userName</code> property in the viewModel or <code>value</code> attribute on the <code>input</code> element to the <code>name</code> in the parent scope.</p>
<pre><code class="language-html">&lt;my-component userName:bind=&quot;name&quot;&gt;&lt;/my-component&gt;

&lt;input value:bind=&quot;name&quot; type=&quot;text&quot;&gt;
</code></pre></li>
</ul>
<p>Create bindings to viewModel or DOM events:</p>
<ul>
<li><a href="https://canjs.com/doc/can-stache-bindings.event.html">on:EVENT=&quot;handler()&quot;</a> - Listen to the DOM event or viewModel <code>EVENT</code> and use <code>handler</code> as the event handler.</li>
</ul>
<p>Listen to the <code>click</code> event emitted by a DOM element:</p>
<pre><code>```html
&lt;div on:click=&quot;updateThing()&quot;&gt;&lt;/my-component&gt;
```
</code></pre>
<p>Listen to the <code>show</code> event emitted by the viewModel, <code>vm</code>:</p>
<pre><code>```html
&lt;my-component on:show=&quot;showTheThing()&quot;&gt;&lt;/my-component&gt;
```
</code></pre>
<h3>can-component</h3>
<p><a href="https://canjs.com/doc/can-component.html">can-component</a> lets you
create widgets with well-defined View Models and are instantiated with
custom elements.</p>
<p>Define a <code>can-component</code> by extending one with a <code>tag</code> name, <a href="#candefine">can-define</a> <code>viewModel</code> and
<a href="#canstache">can-stache template</a> like:</p>
<pre><code class="language-js">// Define the view model
var HelloViewModel = DefineMap.extend({
  excitedMessage: function(){
    return this.attr(&quot;message&quot;)+&quot;!&quot;
  }
});

Component.extend({
  tag: &quot;hello-world&quot;,
  ViewModel: HelloViewModel,
  view: stache(&quot;&lt;h1&gt;{{excitedMessage}}&lt;/h1&gt;&quot;)
});
</code></pre>
<p>To instantiate this component so it says <code>Hello World!</code>, add
a <code>&lt;hello-world&gt;</code> element to the page like:</p>
<pre><code class="language-html">&lt;hello-world message=&quot;Hello World&quot;/&gt;
</code></pre>
<p>Use <a href="#canstachebindings">can-stache-bindings</a>
to send a value from the <code>can-stache</code> scope like:</p>
<pre><code class="language-js">// a `DefineMap` that will be available in the scope
var appViewModel = new DefineMap({
  greeting: &quot;Howdy Planet&quot;
});

var template = stache('&lt;hello-world message:from=&quot;greeting&quot;/&gt;');

var frag = template(appViewModel);

frag //-&gt; &lt;hello-world message:from=&quot;greeting&quot;&gt;
     //      &lt;h1&gt;Howdy Planet!&lt;/h1&gt;
     //   &lt;/hello-world&gt;
</code></pre>
<p><code>can-component</code>s are usually built as <a href="./Features.html#modlets">modlets</a>,
meaning their template and styles are another file and imported:</p>
<pre><code class="language-js">// hello-world.js
import Component from 'can-component';
import Map from 'can-define/map/map';
import './hello-world.less';
import view from './hello-world.stache';

export const ViewModel = Define.extend({
  message: &quot;string&quot;,
  excitedMessage: function(){
    return this.message+&quot;!&quot;
  }
});

export default Component.extend({
  tag: &quot;hello-world&quot;,
  ViewModel: ViewModel,
  view
});
</code></pre>
<p>Some components are so small, they they don't require three
separate files. For these, you can use a <code>.component</code> file:</p>
<pre><code class="language-html">&lt;!-- hello-world.component --&gt;
&lt;can-component tag=&quot;&lt;%= tag %&gt;&quot;&gt;
  &lt;style type=&quot;less&quot;&gt;
    display: block;
  &lt;/style&gt;
  &lt;template&gt;
    &lt;h1&gt;{{excitedMessage}}&lt;/h1&gt;
  &lt;/template&gt;
  &lt;view-model&gt;
    import DefineMap from 'can-define/map/map';

    export default DefineMap.extend({
      message: &quot;string&quot;,
      excitedMessage: function(){
        return this.message+&quot;!&quot;
      }
    });
  &lt;/view-model&gt;
&lt;/can-component&gt;
</code></pre>
<h3>can-route</h3>
<p><a href="https://canjs.com/doc/can-route.html">can-route</a> provides powerful 2-way, nested, routing to your application, supporting both hash and <a href="https://canjs.com/doc/can-route-pushstate.html">pushstate</a>.</p>
<p>Configure routing rules to define property values on your application's
View Model when a url is matched.</p>
<p>The following sets the application ViewModel's <code>page</code> property
to <code>&quot;chat&quot;</code> when the url looks like <code>/chat</code>:</p>
<pre><code class="language-js">route.register(&quot;{page}&quot;);
</code></pre>
<p>You can define defaults that get set when <code>{page}</code> is empty. The
following sets the default <code>page</code> property to <code>&quot;home&quot;</code>.</p>
<pre><code class="language-js">route.register(&quot;{page}&quot;, { page: &quot;home&quot; });
</code></pre>
<p>You can specify multiple properties to set for a given url:</p>
<pre><code class="language-js">route.register(&quot;{page}/{slug}&quot;);
route.register(&quot;{page}/{slug}/{action}&quot;);
</code></pre>
<p>Update the url by changing <code>can-route</code>:</p>
<pre><code class="language-js">route.attr(&quot;page&quot;, &quot;restaurants&quot;);
// location.href -&gt; &quot;/restaurants&quot;
</code></pre>
<p>Or change <code>route</code> by modifying the url:</p>
<pre><code class="language-js">history.pushState(null, null, &quot;/&quot;);
// route.attr(&quot;page&quot;); // -&gt; &quot;home&quot;
</code></pre>
<p>In a DoneJS application can.route is bound to the <a href="#candefine">application View Model</a>, but you can connect <code>can-route</code> to other
maps:</p>
<pre><code class="language-js">var DefineMap = require(&quot;can-define/map/map&quot;);

var AppViewModel = DefineMap.extend({
 ...
});

var viewModel = new AppViewModel();

route.data = viewModel;
</code></pre>
<p>Which will cause any changes in the route to reflect in the View Model instance, and any changes in the View Model instance to reflect in the route.</p>
<h2>Data Layer APIs</h2>
<h3>can-realtime-rest-model</h3>
<p><a href="https://canjs.com/doc/can-realtime-rest-model.html">can-realtime-rest-model</a> is used to connect typed
data to backend services.  In a DoneJS application, that typed data is a
<a href="#candefine">can-define/map/map</a> and <a href="#candefinelistlist">can-define/list/list</a> type.</p>
<p>To make a simple connection to a restful interface:</p>
<pre><code class="language-js">// First, create custom Map and List type
var Todo = DefineMap.extend({
  ownerId: &quot;number&quot;,
  canComplete: function(ownerId) {
    return this.ownerId === ownerId;
  }
});

var TodoList = DefineList.extend({
  &quot;*&quot;: Todo
},{
  incomplete: function(){
    return this.filter(function(todo){
      return !todo.complete;
    });
  }
});

// Then, make a connection with the right behaviors and options.
var todoConnection = realtimeRestModel({
  Map: Todo,
  List: TodoList,
  url: &quot;/services/todos&quot;
});
</code></pre>
<p>This adds a <a href="https://canjs.com/doc/can-connect/can/map/map.getList.html">getList</a>,
<a href="https://canjs.com/doc/can-connect/can/map/map.get.html">.get</a>,
<a href="https://canjs.com/doc/can-connect/can/map/map.prototype.save.html">.save</a> and
<a href="https://canjs.com/doc/can-connect/can/map/map.prototype.destroy.html">.destroy</a> methods to
<code>Todo</code> allowing you to CRUD <code>Todo</code>s and <code>TodoList</code>s from the service layer like:</p>
<pre><code class="language-js">// Get a list of todos
Todo.getList({due: &quot;today&quot;}).then(function(todos){ ... });

// Get a single todo
Todo.get({id: 5}).then(function(todo){ ... });

// Create a todo
var todo = new Todo({name: &quot;dishes&quot;})

// Create it on the server
todo.save().then(function(todo){

  // Update its properties
  todo.name = &quot;Do the dishes&quot;;
  // Update the service layer with changes
  todo.save().then(function(todo){

    // Delete the todo on  the service layer
    todo.destroy();
  });
});
</code></pre>
<p><code>can-connect</code> comes with a wide variety of behaviors that
can be mixed into a connection.  Examples include:</p>
<ul>
<li><a href="https://canjs.com/doc/can-connect/real-time/real-time.html">real-time</a> keeps <code>can.List</code>s updated with changes.</li>
<li><a href="https://canjs.com/doc/can-connect/fall-through-cache/fall-through-cache.html">fall-through-cache</a></li>
</ul>
<p>To make the process of creating <code>can.Map</code> based connections easier,
DoneJS comes with a <a href="#generators">supermodel generator</a>
creates a <a href="https://canjs.com/doc/can-connect/can/super-map/super-map.html">super-map</a>.</p>
<p>A realtime rest model is just a connection with a bunch of the mostly commonly used
behaviors.  Create one with the <code>superMap</code> function like:</p>
<pre><code class="language-js">export const messageConnection = realtimeRestModel({
  url: &quot;/services/todos&quot;,
  Map: Todo,
  List: TodoList,
  name: 'todo'
});
</code></pre>
<h3>can-query-logic</h3>
<p><a href="https://canjs.com/doc/can-query-logic.html">can-query-logic</a> is used to define the rules of an API service, in order to compare queries that are represented by the parameters commonly passed
to service requests.</p>
<p>For example, if you want all todos for user <code>5</code> that are complete, you
might call:</p>
<pre><code class="language-js">Todo.getList({ filter: { userId: 5, complete: true } })
</code></pre>
<p><code>{userId: 5, complete: true}</code> represents a set.  Using
<code>can-query-logic</code> we can compare it to other sets. The following
returns <code>true</code> because <code>{userId: 5, complete: true}</code> represents
a subset of <code>{userId: 5}</code>.</p>
<pre><code class="language-js">queryLogic.isSubset({filter:{userId: 5, complete: true}}, {userId: 5}); // -&gt; true
</code></pre>
<p>Behind the scenes can-query-logic uses <code>can-set</code> which can perform more complex logic with custom <a href="https://github.com/canjs/can-set#setalgebra">set Algebras</a>.</p>
<p>The following creates a set-algebra that is able to combine ranges:</p>
<pre><code class="language-js">// Create a set Algebra
var algebra = new set.Algebra(
  set.comparators.rangeInclusive(&quot;start&quot;,&quot;end&quot;));

// use it
algebra.union({start: 1, end: 10},
              {start: 11, end: 20}) //-&gt; {start: 1, end: 20}
</code></pre>
<p>In a DoneJS application, you create custom query logics to pass to <a href="https://canjs.com/doc/can-realtime-rest-model.html">realtime rest model</a> connections. The
connection's behaviors use that <a href="https://canjs.com/doc/can-query-logic.html">querylogic</a> to their optimizations.</p>
<h2>Testing APIs</h2>
<h3>QUnit</h3>
<p><a href="https://qunitjs.com/">QUnit</a> is DoneJS's default JavaScript unit testing framework. It is provided for DoneJS by the <a href="https://github.com/stealjs/steal-qunit">steal-qunit</a> project. A basic unit test for a can.Component view-model looks like this:</p>
<pre><code class="language-js">import QUnit from 'steal-qunit';
import { ViewModel } from 'my/component/';

// ViewModel unit tests
QUnit.module('my/component');

QUnit.test('Has message', function(){
  var vm = new ViewModel();
  QUnit.equal(vm.message, 'This is the my-component component');
});
</code></pre>
<p>While the generators create QUnit tests by default you can switch your own tests easily to <a href="https://github.com/stealjs/steal-jasmine">Jasmine</a> or <a href="https://github.com/stealjs/steal-mocha">Mocha</a>.
To use Mocha instead for the previous view-model example we just need to install the wrapper with</p>
<pre><code>npm install steal-mocha --save-dev
npm install assert --save-dev
</code></pre>
<p>And then change the test file to:</p>
<pre><code class="language-js">import mocha from 'steal-mocha';
import assert from 'assert';
import { ViewModel } from 'my/component/';

mocha.setup('bdd');

// ViewModel unit tests
describe('my/component', function() {
  it('Has a message', function() {
    var vm = new ViewModel();
    assert.equal(vm.message, 'This is the my-component component');
  });
});
</code></pre>
<h3>FuncUnit</h3>
<p><a href="https://funcunit.com/">FuncUnit</a> enhances QUnit, Mocha or Jasmine and enables them to simulate user actions, easily test asynchronous behavior, and support black box testing. It uses a jQuery-like syntax to write functional or unit tests. When generating an application, DoneJS already includes a basic FuncUnit smoke-test which runs alongside the other tests. It looks like this:</p>
<pre><code class="language-js">import F from 'funcunit';
import QUnit from 'steal-qunit';

F.attach(QUnit);

QUnit.module('my-app functional smoke test', {
  beforeEach() {
    F.open('../development.html');
  }
});

QUnit.test('my-app main page shows up', function() {
  F('title').text('my-app', 'Title is set');
});
</code></pre>
<p>This will open the main application (<code>development.html</code> is the HTML file that loads our DoneJS app without server-side-rendering) and ensures that the <code>&lt;title&gt;</code> is set to the name (which is the default in a newly generated application). To learn more about the user interactions and assertions available, follow up in the <a href="https://funcunit.com/docs/index.html">FuncUnit API documentation</a>.</p>
<h3>Testee</h3>
<p><a href="https://github.com/bitovi/testee">Testee</a> is a JavaScript test runner that can run your QUnit, Mocha and Jasmine tests from the command line. The command executed when running <code>donejs test</code> (which is the same as running <code>npm test</code>) is located in the <code>package.json</code> <code>scripts</code> section and already set up to run the main test suite in Firefox like this:</p>
<pre><code>testee src/test.html --browsers firefox --reporter Spec
</code></pre>
<p>To change the browsers that our tests run on we can update the list of browsers, for example to add Safari and Google Chrome Canary by changing the test script to:</p>
<pre><code>testee src/test.html --browsers firefox,canary,safari --reporter Spec
</code></pre>
<p>Testee supports all <a href="https://mochajs.org/#reporters">Mocha command line reporters</a>. For example, running the tests in the default browser <a href="http://phantomjs.org/">PhantomJS</a> (DoneJS only works with PhantomJS &gt;= 2.0) on a <a href="https://jenkins-ci.org/">Jenkins CI</a> server that uses XUnit output from a <code>testresults.xml</code> can be accomplished like this:</p>
<pre><code>testee src/test.html --reporter XUnit &gt; testresults.xml
</code></pre>
<p>For more configuration options follow up in the <a href="https://github.com/bitovi/testee#testee">Testee documentation</a>.</p>
<h2>DocumentJS</h2>
<p>When working on large applications keeping updated documentation is critical.
<a href="https://documentjs.com/">DocumentJS</a> generates API documentation for your
application supporting <a href="http://usejsdoc.org/">JSDoc</a> syntax that can be multi-versioned.</p>
<h3>Configuration</h3>
<p>DocumentJS is configured with a <a href="https://documentjs.com/docs/DocumentJS.docConfig.html">docConfig</a> specified
in a <strong>documentjs.json</strong> file within your project:</p>
<pre><code class="language-js">{
  &quot;sites&quot;: {
    &quot;docs&quot;: {
      &quot;dest&quot;: &quot;docs&quot;,
      &quot;glob&quot; : &quot;**/*.{js,md}&quot;
    }
  }
}
</code></pre>
<p>This specifies to look in JavaScript and Markdown files for jsdoc tags. When ran the documentation will be written to the <strong>docs</strong> folder.</p>
<h3>Documenting</h3>
<p>DocumentJS includes most <a href="https://documentjs.com/docs/documentjs.tags.html">tags</a> you need to document a web application and includes an API to create your own.</p>
<p>Here's how you would document a <a href="#cancomponent">can-component</a> View Model:</p>
<pre><code class="language-js">/**
 * @add order/new
 */
export const ViewModel = Define.extend({
  /**
   * @property {String} slug
   *
   * The restaurants slug (short name). Will
   * be used to request the actual restaurant.
   */
  slug: {
    type: 'string'
  },
  /**
   * @property {place-my-order/models/order} order
   *
   * The order that is being processed. Will
   * be an empty new order inititally.
   */
  order: {
    Default: Order
  },
  /**
   * @property {can.Deferred} saveStatus
   *
   * A deferred that contains the status of the order when
   * it is being saved.
   */
  saveStatus: {
    Default: Object
  },
  /**
   * @property {Boolean} canPlaceOrder
   *
   * A flag to enable / disable the &quot;Place my order&quot; button.
   */
  canPlaceOrder: {
    get() {
      let items = this.order.items;
      return items.length;
    }
  }

  /**
   * @function placeOrder
   *
   * Save the current order and update the status Deferred.
   *
   * @return {boolean} false to prevent the form submission
   */
  placeOrder() {
    let order = this.order;
    this.saveStatus = order.save();
    return false;
  },

  /**
   * @function startNewOrder
   *
   * Resets the order form, so a new order can be placed.
   *
   * @return {boolean} false to prevent the form submission
   */
  startNewOrder: function() {
    this.order = new Order();
    this.saveStatus = null;
    return false;
  }
});
</code></pre>
<h3>Generating</h3>
<p>DoneJS preconfigures your app to be documented with:</p>
<pre><code>donejs document
</code></pre>
<p>Or you can run the <a href="https://documentjs.com/docs/DocumentJS.apis.generate.documentjs.html">documentjs</a> command directly with:</p>
<pre><code>node_modules/.bin/documentjs
</code></pre>
<h2>DOM APIs</h2>
<h3>jQuery</h3>
<p><a href="https://jquery.com/">jQuery</a> is the ubiquitous DOM manipulation
library. While you don't often need to write jQuery directly,
<a href="#canjs">CanJS</a> is built making it safe to use jQuery when needed.</p>
<p>For example, you can make your own custom elements that call jQuery
plugins:</p>
<pre><code class="language-js">callbacks.tag(&quot;tooltip&quot;, function(el){
  $(el).tooltip({
    content: el.getAttribute(&quot;content&quot;),
    items: &quot;tooltip&quot;
  });
})
</code></pre>
<p><a href="#canstachebindings">can-stache-bindings</a> lets you listen
to <a href="http://benalman.com/news/2010/03/jquery-special-events/">jQuery special events</a> like:</p>
<pre><code class="language-html">&lt;div on:tripleclick=&quot;doSomething()&quot;&gt;
</code></pre>
<p><a href="#cancomponent">can-component</a>'s events object also supports this:</p>
<pre><code class="language-js">Component.extend({
  events: {
    &quot;li tripleclick&quot;: function(li, ev){ ... }
  }
})
</code></pre>
<p>CanJS adds special <a href="https://canjs.com/docs/can.events.inserted.html">inserted</a>, <a href="https://canjs.com/docs/can.events.removed.html">removed</a>, and <a href="https://canjs.com/docs/can.events.attributes.html">attributes</a> events. This allows you to
teardown any behavior when the DOM is modified:</p>
<pre><code class="language-js">$(el).bind(&quot;removed&quot;, function(){
  $(el).tooltip(&quot;teardown&quot;);
})
</code></pre>
<p>CanJS's live-binding also hooks into these same events.  So if you remove
an element with jQuery, CanJS will also teardown its bindings.  This means that if
you were to call:</p>
<pre><code class="language-js">$(&quot;body&quot;).empty();
</code></pre>
<h3>jQuery++</h3>
<p><a href="https://jquerypp.com/">jQuery++</a> adds a bunch of special events and other DOM
utilties to jQuery.</p>
<ul>
<li>DOM utilities
<ul>
<li><a href="https://jquerypp.com/#animate">animate</a> - Overwrites <code>jQuery.animate</code> to use CSS3 animations if possible.</li>
<li><a href="https://jquerypp.com/#compare">compare</a> - Compare the position of two elements in the page.</li>
<li><a href="https://jquerypp.com/#range">range</a> - Manipulate text ranges.</li>
<li><a href="https://jquerypp.com/#within">within</a> - Get the elements within a specified area.</li>
</ul></li>
<li>Special events
<ul>
<li><a href="https://jquerypp.com/#drag">drag / drop</a> - drag drop events.</li>
<li><a href="https://jquerypp.com/#hover">hover</a> - hover events.</li>
<li><a href="https://jquerypp.com/#key">key</a> - get a string representation of the key pressed.</li>
<li><a href="https://jquerypp.com/#resize">resize</a> - listen to when an element changes size.</li>
<li><a href="https://jquerypp.com/#swipe">swipe</a> - mobile swipe events.</li>
</ul></li>
</ul>
<h2>Server Side Rendering APIs</h2>
<h3>done-ssr</h3>
<p><a href="https://github.com/donejs/done-ssr">done-ssr</a> enables DoneJS applications to be
server-side rendered. Paired with <a href="#done-autorender">done-autorender</a>
it allows you to render the entire document from a single template.</p>
<pre><code class="language-js">var http = require(&quot;http&quot;);
var ssr = require(&quot;done-ssr&quot;);
var render = ssr();

var server = http.createServer(function(request, response){
    render(request).pipe(response);
});

server.listen(8080);
</code></pre>
<p>The render function is called with a string url to render and returns a response
object that contains the html string that was rendered. Use any Node-based
http framework with done-ssr.</p>
<p>For convenience we have published an <a href="https://expressjs.com/">Express</a> middleware:</p>
<pre><code class="language-js">var ssr = require(&quot;done-ssr-middleware&quot;);
var app = require(&quot;express&quot;)();

app.use(ssr(
  config: __dirname + &quot;/package.json!npm&quot;
));
</code></pre>
<p>Additionally DoneJS has <a href="https://github.com/donejs/done-serve">done-serve</a>
which acts as a rendering front-end for your application. It will host static
content, render your application, and proxy requests to another back-end server.</p>
<pre><code>done-serve --proxy http://localhost:7070 --port 8080
</code></pre>
<h3>done-autorender</h3>
<p><a href="https://github.com/donejs/autorender">done-autorender</a> is a Steal plugin that
enables using a <a href="#canstache">can.stache</a> template as your application's entry point. Create a template like:</p>
<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;app | {{page}}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;can-import from=&quot;app/state&quot; export-as=&quot;viewModel&quot;/&gt;

  &lt;div&gt;Hello {{name}}&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>done-autorender</strong> will insert this template on page load. The <code>can-import</code> tag with
the <code>export-as=&quot;viewModel&quot;</code> attribute is a <a href="#candefine">can-define/map/map</a> that acts as the View Model
for the application.</p>
<p>If you have <a href="https://stealjs.com/docs/steal.live-reload.html#use">live-reload</a> enabled done-autorender will additionally use those APIs to re-render the
application when any modules are reloaded.</p>
<p>done-autorender handles requests when running in Node for server-side rendering and
will wait for all asynchronous events to complete.</p>
<h3>can-simple-dom</h3>
<p><a href="https://github.com/canjs/can-simple-dom">can-simple-dom</a> is a minimal virtual DOM implementation used
for server-side and worker thread rendering. It contains enough of the DOM APIs to get basic
jQuery usage to work, as well as what is typical of CanJS applications.</p>
<p>If you are working on an advanced plugin you might use can-simple-dom directly,
in which case you would import it:</p>
<pre><code class="language-js">import simpleDOM from &quot;can-simple-dom&quot;;

const document = new simpleDOM.Document();
</code></pre>
<p>From here document has the normal DOM apis such as <code>document.createElement</code>.</p>

			</section>
			
			

			

			

		
		</article>
		

	
		</div>
	</div>
	

<survey-ad>
  <button aria-label="Close" class="close" type="button">
    <span aria-hidden="true">&times;</span>
  </button>
  <a href="https://donejs.com/survey.html">
    Help us improve DoneJS by taking our community survey
  </a>
</survey-ad>


	
	<footer>
		<div class="container">
			<div class="row">
				<div class="col-xs-12 col-sm-8">
					<div class="col-xs-1 footer-brand">
						<a href="/"><img src="static/img/donejs-logo-final-02.svg"></a>
					</div>

					<ul class="footer-nav-main list-stacked">
						<li>
							<a href="/">HOME</a>
						</li>
						<li>
							<a href="./Features.html">FEATURES</a>
						</li>
						<li>
							<a href="./About.html">ABOUT</a>
						</li>
						<li>
							<a href="./Apis.html">APIS</a>
						</li>
						<li>
							<a href="./Guides.html">GUIDES</a>
						</li>
						<li>
							<a href="./community.html">COMMUNITY</a>
						</li>
					</ul>
				</div>
				<div class="col-xs-12 col-sm-4">
					<ul class="footer-nav-social list-stacked">
						<li>
							<a href="https://github.com/donejs">
								<img class="footer-social-icon" src="static/img/icon-github-white.svg" alt="Github">
							</a>
						</li>
						<li>
							<a href="https://twitter.com/donejs">
								<img class="footer-social-icon" src="static/img/icon-twitter-white.svg" alt="Twitter">
							</a>
						</li>
						<li>
							<a href="https://plus.google.com/+Bitovi/posts">
								<img class="footer-social-icon" src="static/img/icon-googleplus-white.svg" alt="Google+">
							</a>
						</li>
						<li>
							<a href="https://www.youtube.com/channel/UCEnTQUfJi0L6l7g8IRuaVkg">
								<img class="footer-social-icon" src="static/img/icon-youtube-white.svg" alt="YouTube">
							</a>
						</li>
					</ul>
				</div>
				<div class="clear"></div>
				<div class="footer-copyright col-sm-12">
					&copy; <a href="https://www.bitovi.com/">2015-2019 Bitovi, Inc.</a>
				</div>
			</div>
		</div>
	</footer>
	

	<script type="text/javascript">
		var docObject = {"src":{"path":"docs/apis.md"},"description":"DoneJS is comprised of many projects that are documented separately. This page contains overviews of each project and links to their official APIs. \n### Application Infrastructure\n\nThe blue boxes in the following architecture diagram represent modules provided by DoneJS.\n\n<object type=\"image/svg+xml\" data=\"static/img/donejs-stack-app.svg\"></object>\n\n- [StealJS](#stealjs) - Module loader and build system. [api](https://stealjs.com/docs/index.html).\n- [CanJS](#canjs) - Views, ViewModels, modeling part of Models, custom elements, routing. [api](https://canjs.com/doc/api.html)\n- [can-query-logic](https://canjs.com/doc/can-query-logic.html) Data service modelling.\n- [jQuery](#jquery) - DOM utilities. [api](https://jquery.com/)\n- [done-ssr](#done-ssr) - Incremental server-side rendering for NodeJS. [api](https://github.com/donejs/done-ssr)\n- [done-autorender](#done-autorender) - Processes templates so they can be server-side rendered. [api](https://github.com/donejs/autorender#use)\n- [can-simple-dom](#can-simple-dom) - A lightweight virtual DOM. [api](https://github.com/canjs/can-simple-dom)\n\n### Tooling\n\nDoneJS provides many aspects of JavaScript application tooling, shown in the diagram below.\n\n<object type=\"image/svg+xml\" data=\"static/img/donejs-stack-tooling.svg\"></object>\n\n- [donejs-cli](#cli-and-generators) - The commands available to the donejs command line interface. [api](https://github.com/donejs/cli)\n- [generator-donejs](#cli-and-generators) - Default generators are bundled with DoneJS. [api](https://github.com/donejs/generator-donejs/)\n- [QUnit](#qunit) - Default test assertion library. [api](https://qunitjs.com/)\n- [FuncUnit](#funcunit) - Functional test utilities. [api](https://funcunit.com/)\n- [Testee](#testee) - Browser launcher and test reporter. [api](https://github.com/bitovi/testee)\n- [DocumentJS](#documentjs) - Documentation engine. [api](https://documentjs.com/)\n\n","name":"Apis","type":"page","parent":"DoneJS","hideSidebar":true,"outline":{"depth":2,"tag":"ol"},"comment":" ","pathToRoot":".."};
	</script>

	
		<script type="text/javascript">
		  steal = {
		    instantiated: {
		      "bundles/bit-docs-site/static.css!$css" : null
		    }
		  };
		</script>
		<script
			data-main="bit-docs-site/static"
			src="./static/steal.production.js"
		>
		</script>
	

	<script>
	 (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	 m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	 ga('create', 'UA-2302003-14', 'auto');
	 ga('send', 'pageview');
	</script>
</body>
</html>
