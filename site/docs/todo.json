c({"name": "todo", "type": "page", "comment": "<h2>Introduction</h2>\n\n<p>In this article we will be learning the basics of <a href=\"http://javascriptmvc.com/\">JavaScriptMVC</a> and the <a href=\"http://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller\">Model-View-Controller pattern</a> by installing and walking through a simple To-do list manager. The separation of the application's core logic from its user interface behavior is the hallmark of MVC. By working through this exercise you will understand how JavaScriptMVC's particular flavor of this pattern enables you to create more flexible and maintainable browser-based applications.</p>\n\n<p>Let's get started!</p>\n\n<h2>Setup</h2>\n\n<p>First, clone the application from our <a href=\"http://github.com/jupiterjs/todo\">repository</a> at GitHub, and initialize all the necessary submodules. The following commands will get you up and running:</p>\n\n<pre><code>$ git clone https://github.com/jupiterjs/todo\n$ cd todo\n$ git submodule update --init\n</code></pre>\n\n<p>This bundle now contains everything you need to run the application locally. Since there is no server-side dependency, you can now open the <code>todo/todo.html</code> file in your browser and see it in action.</p>\n\n<p><img class='image_tag' src='tutorials/images/todos.png' /></p>\n\n<h2>Structure</h2>\n\n<p>Now let's take a look at the anatomy of our application:</p>\n\n<pre><code>/todo [top-level, the GitHub repository]\n  /jquery\n  /steal\n  /funcunit\n  /todo\n    /scripts\n    /test\n    funcunit.html\n    qunit.html\n    todo.css\n    todo.html\n    todo.js\n    ...\n</code></pre>\n\n<p>Breaking it down:</p>\n\n<ul>\n<li>The <code>jquery</code> folder is where the <a href=\"http://github.com/jupiterjs/jquerymx\">jQueryMX</a> library lives. JavaScriptMVC consists of powerful abstractions like [jQuery.Class Class], [jQuery.Model Model], [jQuery.Controller Controller], and [jQuery.View View], as well as numerous helpful jQuery plugins like <code>resize</code>, <code>destroyed</code>, <code>closest</code>, <code>curStyles</code>, and <code>route</code> -- all designed to enhance your life as a JavaScript developer.</li>\n<li>The <code>steal</code> folder houses the <a href=\"http://github.com/jupiterjs/steal\">Steal</a> dependency management system, which is what makes it possible to keep your project organized during development, and compact and fast in production. Steal has two main responsibilities: As a JavaScript library, it facilitates on-demand loading of any resources (scripts, stylesheets, templates, or even user-defined content) your application requires. As a command line utility, it takes care of bundling, compressing, and optimizing your application for deployment.</li>\n<li>The <a href=\"http://github.com/jupiterjs/funcunit\">FuncUnit</a> testing framework lives in the <code>funcunit</code> folder -- think jQuery's excellent Qunit framework plus Selenium and headless (Env.js) support. Basically, qUnit on steroids.</li>\n<li>Lastly, our application files will live in the <code>todo</code> folder.</li>\n</ul>\n\n<h2>MVC in JavaScript</h2>\n\n<p>MVC is a well-established architectural pattern in software engineering. Without going into too much detail, it states that there should be a clear separation of concerns between the part of the system that represents the application's core logic and state (Model), the part that renders the user interface (View), and the part that coordinates between the two (Controller). Since our application consists of only one model, one controller, and a handful of templates, we're going to keep all our code in the <code>todo.js</code> and <code>todo.html</code> files. (Ordinarily in a JavaScriptMVC application, we'd keep a single component in each file for ease of navigation, but you'll forgive us this time for keeping it simple.)</p>\n\n<p>The diagram below shows how we've broken our application out into model, view, and controller layers:</p>\n\n<p><img class='image_tag' src='tutorials/images/todo_arch.png' /></p>\n\n<h3>Dependencies</h3>\n\n<p>If you look at <code>todo.js</code> the first thing you'll notice is that all the code is wrapped in a call to the <code>steal</code> function:</p>\n\n<pre><code>steal('jquery/model/list',\n      'jquery/controller',\n      'jquery/view/ejs',\n      'jquery/lang/json',\n      './todo.css',\n      function($){ ... })\n</code></pre>\n\n<p>In fact, this is true of every JavaScript file in a JavaScriptMVC application: we use <code>steal</code> to state our dependencies up-front, which tells the framework what libraries, plugins, stylesheets, etc. we need to load before we can begin. Typically, the final argument to <code>steal</code> will be a callback function, which will be executed when all the other dependencies (and <em>their</em> dependencies, and so on...) have been loaded and executed as well. No more worrying whether you forgot any <code>&lt;script&gt;</code> tags, or whether you've got them in the right order!</p>\n\n<blockquote>\n  <p>For our application, we can see that our script requires the [jQuery.Model.List Model.List] class (which itself requires the [jQuery.Model Model] class), the [jQuery.Controller Controller] class, a jQuery JSON helper, and our application's stylesheet.</p>\n</blockquote>\n\n<h3>Model</h3>\n\n<p>All models in JavaScriptMVC extend the [jQuery.Model Model] class:</p>\n\n<pre><code>$.Model('Todo', { /* static properties */ }, { /* instance/prototype properties */ })\n</code></pre>\n\n<blockquote>\n  <p>If you need a quick refresher on how to use JVMC's classes, see [jQuery.Class Class].</p>\n</blockquote>\n\n<p>In the case of our application, the <code>Todo</code> model represents a single To-do item. Its job is simply to know about the name and completed state of the item, how to persist that information, and how to notify the rest of the application when the item is created, updated, or destroyed.</p>\n\n<p>Since we want our To-do list manager to function without a server, we need some form of persistence in the browser. Sure, cookies are nice, but we're looking to the future -- so lets take advantage of HTML5's LocalStorage! We'll define a <code>Todo</code> model class with a static (i.e. shared across all instances), state-of-the-art HTML5 storage mechanism (don't worry too much about what this does). The <code>localStore</code> method accepts a callback function which will be invoked with an array of <code>Todo</code> object <em>properties</em>. All of our CRUD operations will use this helper in order to persist <code>Todo</code> items in the system:</p>\n\n<pre><code>$.Model('Todo', {\n  /**\n   * Gets JSON data from localStorage.  Any changes that \n   * get made in cb get written back to localStorage.\n   * \n   * This is unimportant for understanding JavaScriptMVC!\n   */\n  localStore: function(cb){\n    var name = this.shortName,\n      data = $.evalJSON(window.localStorage[name] || (window.localStorage[name] = \"{}\")),\n      res = cb.call(this, data);\n    if(res !== false){\n      window.localStorage[name] = $.toJSON(data);\n    }\n  }\n</code></pre>\n\n<p>Given the <code>localStorage</code> helper we've created, we can now define a finder method that returns all <code>Todos</code> that the application knows about. Inside the callback, we just iterate over those objects, and create <code>Todo</code> models out of them:</p>\n\n<pre><code>  findAll: function(params, success){\n    this.localStore(function(todos){\n      var instances = [];\n      for(var id in todos){\n        instances.push(new this(todos[id]))\n      }\n      success &amp;&amp; success(instances)\n    })\n  }\n</code></pre>\n\n<blockquote>\n  <p><em>Tip</em>: Don't let that <code>new this( ... )</code> trip you up. Since we're in the static (class) context, <code>this</code> simply refers to the <code>Todo</code> class itself. Writing <code>new Todo( ... )</code> would have the same effect, but this way our code won't break if we ever decide to rename the class to something else.</p>\n</blockquote>\n\n<p>The static <code>create</code> and <code>update</code> methods may be called directly, but are most often invoked automatically by the model layer when an instance is saved. The <code>create</code> method expects an <code>attrs</code> argument to describe the properties of the To-do item we want to create:</p>\n\n<pre><code>create: function(attrs, success){\n  this.localStore(function(todos){\n    attrs.id = attrs.id || parseInt(100000 * Math.random());\n    todos[attrs.id] = attrs;\n  });\n  success({id: attrs.id})\n}\n</code></pre>\n\n<p><code>Update</code> is similar to <code>create</code>, but rather than adding a new object to local storage, an existing object is looked up and modified in place with <code>jQuery.extend</code>:</p>\n\n<pre><code>update: function(id, attrs, success){\n  this.localStore(function(todos){\n    var todo = todos[id];\n    $.extend(todo, attrs);\n  });\n  success({});\n}\n</code></pre>\n\n<h3>Model Lists</h3>\n\n<p>One of the really great features of JavaScriptMVC is the [jQuery.Model.List Model.List]. A Model.List gives us a way to manage a collection of models as an aggregate, and (the cool part) be able to respond to and trigger events at the collection level. For our present purposes, we'd like to have a list of <code>Todo</code> items that can tell us which ones have been marked as completed:</p>\n\n<pre><code>$.Model.List('Todo.List', {\n  /**\n   * Return a new Todo.List of only complete items\n   */\n  completed : function(){\n    return this.grep(function(item){\n      return item.complete === true;\n    })\n  }\n})\n</code></pre>\n\n<blockquote>\n  <p>The <code>grep</code> method is similar to <code>jQuery.grep</code> in that it applies a filter to the list and returns a new list of all items for which the filter is true.</p>\n</blockquote>\n\n<p>We'll see how lists really make our lives easier when it comes time to do our view rendering below.</p>\n\n<h3>Controller and View</h3>\n\n<p>Controllers in JavaScriptMVC get their mojo from the [jQuery.Controller Controller] class. Basically, you can think of Controller as a <a href=\"http://jupiterjs.com/news/organize-jquery-widgets-with-jquery-controller\">factory for building jQuery plugins</a>: its job is to attach itself to a DOM element, and organize event handlers using event delegation.</p>\n\n<p>Unlike models, controllers and views are inherently tied to the application's user interface, so before we dive into the JavaScript code, let's take a quick look at the basic HTML structure of the application:</p>\n\n<pre><code>&lt;div id='todos'&gt;\n  &lt;h1&gt;Todos&lt;/h1&gt;\n  &lt;input type='text' class='create' /&gt; \n  &lt;ul id='list'&gt;\n  &lt;/ul&gt;\n  &lt;div id='todo-stats'&gt;\n  &lt;/div&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>Not much to it! One wrapper element -- that's the element we're eventually going to attach the controller to -- and inside that wrapper, the following items:</p>\n\n<ul>\n<li>A title (\"Todos\")</li>\n<li>A text box where we're going to add new To-do items</li>\n<li>A list where we'll see all current To-do items</li>\n<li>Another container for \"stats\" where we'll show a count of what the user has selected, and give them a way to \"finish\"\nitems</li>\n</ul>\n\n<p>With this document structure in mind, let's create our controller:</p>\n\n<pre><code>$.Controller('Todos', {\n  // sets up the widget\n  init : function(){\n    // empties the create input element\n    this.find(\".create\").val(\"\")[0].focus();\n\n    // fills this list of items (creates add events on the list)\n    this.options.list.findAll();\n  }\n</code></pre>\n\n<p>The <code>init</code> method will be called when we initialize the controller with <code>$( ... ).todos()</code>. Upon initialization, we first want to clear the text box and then \"focus\" it (that is, place the mouse cursor in it). Nothing too unusual here.</p>\n\n<blockquote>\n  <p>In the context of a controller, the <code>find</code> method is like <code>jQuery.find</code> in that it searches for a selector underneath the element being managed by the controller.</p>\n</blockquote>\n\n<p>Next, we want to fetch the current collection of To-do items and display them to the user. Now, fetching and rendering data is something we do all the time, and it is very common practice in JavaScript and jQuery programming to perform both of these actions in one place. If we had some helpers lying around for fetching and rendering To-dos, we might do something like this, for example:</p>\n\n<pre><code>findAllTodos(function(todos){\n  $('#list').html(renderTodosHTML(todos))\n})\n</code></pre>\n\n<p>What's wrong with this kind of approach? Well, nothing is <em>wrong</em> with it, per se. In a simple example like this one, we could probably get away with it. The problem comes as the application scales up in complexity, and there become more and more scenarios that can trigger a refresh of this list. The user may be allowed to create new To-do items manually, or import them from another source -- or even synchronize with another application running in the cloud. If we use this approach, we duplicate this hard-wiring of fetching and rendering all over the application, and make it more brittle and difficult to change in the future.</p>\n\n<p>JavaScriptMVC Controller takes a more scalable approach to this problem through its event mechanism. Rather than rendering the list explicitly in the fetch callback, we simply ask the <code>Todo.List</code> to perform a <code>findAll</code> on itself. When the fetch completes, the list fires its own \"add\" event, which we listen for in the Controller. Conveniently, the \"add\" event tells us everything we need to know: the list that published the event, the jQuery event that triggered the add, and the To-do items which were added:</p>\n\n<pre><code>// adds existing and created to the list\n\"{list} add\": function(list, ev, items) {\n\n  // uses the todosEJS template (in todo.html) to render a list of items\n  // then adds those items to #list\n  this.find('#list').append(\"todosEJS\", items)\n\n  // calls a helper to update the stats info\n  this.updateStats();\n}\n</code></pre>\n\n<p>The list template (\"todosEJS\") we're using to perform the render looks like this:</p>\n\n<pre><code>&lt;% for(var i = 0; i &lt; this.length; i++){ %&gt;\n  &lt;li &lt;%= this[i]%&gt;&gt;\n    &lt;%== $.View('todoEJS', this[i]) %&gt;\n  &lt;/li&gt;\n&lt;% } %&gt;\n</code></pre>\n\n<p>You may be wondering what that strange syntax is doing on the second line: <code>&lt;li &lt;%= this[i]%&gt;&gt;</code>. This little bit of magic is what is known as a hookup. What's happening here is that each Todo model is being bound to its respective list item HTML element. This little binding provides some very important functionality. First, it allows you to easily retrieve one or more models given a jQuery object, by using the <code>.model()</code> or <code>.models()</code> methods. Secondly, it creates an automatic listener that will update or remove the element when its associated model changes!</p>\n\n<p>A little note on templated event handlers: the <code>{list}</code> which appears in the event descriptor is the same as the <code>this.options.list</code> which we saw earlier in our <code>init</code> method. When we bind our controller to its DOM element, we tell it about the [jQuery.Model.List Model.List] that we want it to manage:</p>\n\n<pre><code>// create a todos widget with a list\n$(\"#todos\").todos({ list: new Todo.List() })\n</code></pre>\n\n<blockquote>\n  <p>Any parameters passed into the controller's initialization object become available on the <code>options</code> property of the controller, and also via the {} syntax in event descriptors.</p>\n</blockquote>\n\n<p>In a similar way, we will listen for the list's \"remove\" and \"update\" events. Upon removal of any To-do items, we want to remove it from the list also. Once again, the event gives us all the information we need to know:</p>\n\n<pre><code>// when an item is removed from the list ...\n\"{list} remove\": function(list, ev, items) {\n\n  // get the elements in the list and remove them\n  items.elements(this.element).slideUp(function(){\n    $(this).remove();\n  });\n\n  this.updateStats();\n}\n</code></pre>\n\n<p>The \"updated\" event is fired both on individual items and on the list as a whole. In this case, we want to render the single item template (\"todoEJS\") to replace the HTML of the item which was changed:</p>\n\n<pre><code>// when an item is updated\n\"{list} updated\": function(list, ev, item) {\n  item.elements().html(\"todoEJS\", item);\n  this.updateStats();\n}\n</code></pre>\n\n<p>Now, let's look at how new To-do items are created. In a modern web interface, we no longer want to depend on fat forms and submit buttons -- we want to do small bits of work anytime the user performs an appropriate action. Rather than making the user constantly move between the keyboard and mouse, we listen for a press of the Enter key to trigger a save:</p>\n\n<pre><code>// listens for key events and creates a new todo\n\".create keyup\": function(el, ev) {\n  if(ev.keyCode == 13){\n    new Todo({\n      text: el.val(),\n      complete: false\n    }).save(this.callback('created'));\n\n    el.val(\"\");\n  }\n}\n</code></pre>\n\n<p>Remember our discussion above about decoupling fetching from rendering? It applies here, too: rather than simply rendering the newly created To-do item when the save completes, we call our <code>created</code> method, which adds the item to the <code>Todo.List</code>:</p>\n\n<pre><code>// When a todo is created, add it to this list\n\"created\": function(todo) {\n  this.options.list.push(todo); //triggers 'add' on the list\n}\n</code></pre>\n\n<p>This causes the \"add\" event to fire, which in turn triggers our <code>\"{list} add\"</code> handler above. We don't have to write any new code to handle this render: it's already happening automatically! Nowhere in the application have we explicitly bound any model callbacks to changes in the view: everything happens through events.</p>\n\n<h2>That's It!</h2>\n\n<p>JavaScriptMVC enables you to write even the simplest application <strong>the right way</strong> from the start. With a Model that's completely independent from any knowledge of user interface behavior, and a Controller that's all ready to scale up to the complexities of modern Web experiences, you won't find yourself rewriting your app over and over again to deliver the goods.</p>", "title": "Todo", "parents": ["examples"], "order": 2, "src": "tutorials/examples/todo.md", "children": []})