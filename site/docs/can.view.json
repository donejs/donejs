c({"name": "can.view", "type": "function", "comment": "<p>can.view is a JavaScript template framework that provides:</p>\n\n<ul>\n<li>template loading from html elements or external files</li>\n<li>synchronous and asynchronous template loading</li>\n<li>deferred support</li>\n<li>callbacks on elements for functionality like live live-binding</li>\n</ul>\n\n<p>can.view supports other templating languages, but using [can.EJS] is highly encouraged.</p>\n\n<h2>Use</h2>\n\n<p><code>can.view( idOrUrl, data)</code> loads template content from an element or url, renders\nit with data, and converts it to a documentFragment so it can be easily and \nefficiently inserted into the DOM.</p>\n\n<pre><code>document.getElementById('person')\n  .appendChild( can.view('person.ejs', {name: \"Justin\" } ) )\n</code></pre>\n\n<p>This code:</p>\n\n<ol>\n<li><p>Loads the template a 'mytemplate.ejs'. It might look like:\n<pre><code>&lt;h2>&lt;%= name %>&lt;/h2></pre></code></p></li>\n<li><p>Renders it with {message: 'hello world'}, resulting in:\n<pre><code>&lt;div id='foo'>\"&lt;h2>Justin&lt;/h2>&lt;/div></pre></code></p></li>\n<li><p>Inserts the result into the foo element. Foo might look like:\n<pre><code>&lt;div id='person'>&lt;h2>Justin&lt;/h2>&lt;/div></pre></code></p></li>\n</ol>\n\n<h2>Loading Templates</h2>\n\n<p><code>can.view</code> can load templates from a url or from a script.</p>\n\n<h3>Loading templates from a script tag</h3>\n\n<p>To load from a script tag, create a script tag with:</p>\n\n<ul>\n<li>the template contents within the script tag</li>\n<li>an id</li>\n<li><p>a type attribute that specifies the type of template</p>\n\n<script type='text/ejs' id='recipesEJS'>\n<% for(var i=0; i < recipes.length; i++){ %>\n  <li><%=recipes[i].name %></li>\n<%} %>\n</script></li>\n</ul>\n\n<p>Render with this template like:</p>\n\n<pre><code>document.getElementById('recipes')\n  .appendChild( can.view('recipesEJS', recipeData ) )\n</code></pre>\n\n<p>Notice we passed the id of the element we want to render.</p>\n\n<h3>Loading templates from a url</h3>\n\n<p>To load from a url, simply pass the location of the template\nto <code>can.view</code>.  The location of the template needs an extension that\nmatches the type of template:</p>\n\n<pre><code>document.getElementById('recipes')\n  .appendChild( can.view('templates/recipes.ejs', recipeData ) )\n</code></pre>\n\n<h2>Supported Template Engines</h2>\n\n<p>CanJS supports the following template languages:</p>\n\n<ul>\n<li><p>EmbeddedJS (ejs)</p>\n\n<pre><code>&lt;h2>&lt;%= message %>&lt;/h2></code></pre></li>\n<li><p>JAML (jaml)</p>\n\n<pre><code>h2(data.message);</code></pre></li>\n<li><p>Micro (micro)</p>\n\n<pre><code>&lt;h2>{%= message %}&lt;/h2></code></pre></li>\n<li><p>jQuery.Tmpl (tmpl)</p>\n\n<pre><code>&lt;h2>${message}&lt;/h2></code></pre></li>\n</ul>\n\n<h2>Rendering to strings and sub-templates</h2>\n\n<p>To render to a string, use <code>can.view.render(idOrUrl, data)</code> like:</p>\n\n<pre><code>can.view.render(\"/templates/recipe.ejs\",{recipe: recipe})\n</code></pre>\n\n<p>To render a sub-template within another template, use render like:</p>\n\n<pre><code>&lt;% $.each(recipes, function(i, recipe){ %&gt;\n  &lt;li&gt;&lt;%== can.view.render(\"/templates/recipe.ejs\",{\n             recipe: recipe\n            }) %&gt;\n  &lt;/li&gt;\n&lt;% }) %&gt;\n</code></pre>\n\n<h2>Asynchronous Loading</h2>\n\n<p>By default, retrieving templates is done synchronously. This \nis fine because StealJS packages view templates with your \nJS download.</p>\n\n<p>However, some people might not be using StealJS or want to \ndelay loading templates until necessary. If you have the need, \nyou can provide a callback paramter like:</p>\n\n<pre><code>can.view('recipes',recipeData, function(frag){\n  document.getElementById('recipes')\n    .appendChild(frag)\n});\n</code></pre>\n\n<p>The callback function will be called with the result of \nthe rendered template.</p>\n\n<h2>Deferreds</h2>\n\n<p>If you pass deferreds to can.view it \nwill wait until all deferreds resolve before rendering \nthe view. This makes it a one-liner to make a request and use the \nresult to render a template.</p>\n\n<p>The following makes a request for todos in parallel with the \ntodos.ejs template. Once todos and template have been loaded, \nit with render the view with the todos.</p>\n\n<pre><code>can.view('recipes', Todo.findAll() , function(frag){\n  document.getElementById('recipes')\n    .appendChild(frag)\n})\n</code></pre>", "parents": ["canjs"], "description": "A JavaScript template framework.", "src": "can/view/view.md", "children": []})