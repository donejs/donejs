c({"name": "can.Observe", "type": "class", "comment": "<p>can.Observe provides the observable pattern for\nJavaScript Objects. It lets you</p>\n\n<ul>\n<li>Set and remove property or property values on objects</li>\n<li>Listen for changes in objects and arrays</li>\n<li>Work with nested properties</li>\n</ul>\n\n<h2>Creating an Observe</h2>\n\n<p>To create an observable object, use <code>new can.Observe( [obj] )</code> like:</p>\n\n<pre><code>var person = new can.Observe({ name: 'justin', age: 29 });\n</code></pre>\n\n<p>To create an observable array, use <code>new can.Observe.List( [array] )</code> like:</p>\n\n<pre><code>var hobbies = new can.Observe.List([\n                    'programming', \n                    'basketball',\n                    'nose picking'\n]);\n</code></pre>\n\n<p>can.Observe and [can.Observe.List] are very similar. In fact,\ncan.Observe.List inherits can.Observe and only adds a few extra methods for\nmanipulating arrays, like [can.Observe.List::push push].  See\n[can.Observe.List] for more information about lists.</p>\n\n<p><code>Observe</code> works with nested objects and arrays, so the following works:</p>\n\n<pre><code>var data = { \n  addresses: [\n    {\n      city: 'Chicago',\n      state: 'IL'\n    },\n    {\n      city: 'Boston',\n      state: 'MA'\n    }\n  ],\n  name: 'Justin Meyer'\n},\no = new can.Observe( data );\n</code></pre>\n\n<p><em>o</em> now represents an observable copy of <em>data</em>.  </p>\n\n<p>Observe is inherited by [can.Model].</p>\n\n<h2>Getting and Setting Properties</h2>\n\n<p>Use [can.Observe::attr attr] to get and set properties.</p>\n\n<p>For example, you can <strong>read</strong> the property values of <em>o</em> with\n<code>observe.attr( name )</code> like:</p>\n\n<pre><code>// read name\no.attr( 'name' ) //-&gt; Justin Meyer\n</code></pre>\n\n<p>And <strong>set</strong> property names of <em>o</em> with \n<code>observe.attr( name, value )</code> like:</p>\n\n<pre><code>// update name\no.attr( 'name', 'Brian Moschel' ) //-&gt; o\n</code></pre>\n\n<p>Observe handles nested data.  Nested Objects and\nArrays are converted to can.Observe and \ncan.Observe.Lists.  This lets you read nested properties \nand use can.Observe methods on them.  The following \nupdates the second address (Boston) to 'New York':</p>\n\n<pre><code>o.attr( 'addresses.1' ).attr({\n  city: 'New York',\n  state: 'NY'\n});\n</code></pre>\n\n<p><code>attr()</code> can be used to get all properties back from the observe:</p>\n\n<pre><code>o.attr() // -&gt; \n{ \n  addresses: [\n    {\n      city: 'Chicago',\n      state: 'IL'\n    },\n    {\n      city: 'New York',\n      state: 'MA'\n    }\n  ],\n  name: 'Brian Moschel'\n}\n</code></pre>\n\n<h2>Listening to property changes</h2>\n\n<p>When a property value is changed, observe fires a <code>change</code> event.\nCalling <code>bind( 'change', handler( ev, attr, how, newVal, oldVal ) )</code> listens\nto any attribute change that happens on the observe. The handler will be\ninvoked with the property name that was changed, how it was changed\n('add', 'remove', or 'set'), the new value, and the old value:</p>\n\n<pre><code>o = new can.Observe({});\no.bind( 'change', function( ev, attr, how, nevVal, oldVal ) {\n    // ev    -&gt; { type: 'change' }\n    // attr  -&gt; \"name\"\n    // how   -&gt; \"add\"\n    // newVal-&gt; \"Justin\"\n    // oldVal-&gt; undefined \n});\n\no.attr( 'name', 'Justin' );\n</code></pre>\n\n<p>A more powerful delegation mechanism is also available through the\n[can.Observe.delegate] plugin. Calling\n<code>delegate( attr, event, handler( ev, newVal, oldVal ) )</code> listens\nto a specific event on a specific attribute or pattern:</p>\n\n<pre><code>// listen for name changes\no = new can.Observe({});\no.delegate( 'name', 'set', function( ev, newVal, oldVal ) {\n    // ev     -&gt; { type: 'change' }\n    // newVal -&gt; 'Justin'\n    // oldVal -&gt; undefined\n});\n\no.attr( 'name', 'Justin' );\n</code></pre>", "parents": ["canjs"], "test": "can/observe/qunit.html", "construct": "<p>Creates a new Observe with its data.</p>", "ret": {"type": "can.observe", "description": ""}, "params": {"obj": {"order": 0, "description": "<p>a JavaScript Object that will be converted to an observable</p>", "name": "obj", "type": "Object", "optional": true}}, "src": "can/observe/observe.md", "children": ["can.Observe.setter", "can.Observe.sort", "can.Observe.validations"]})