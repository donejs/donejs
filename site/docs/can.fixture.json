c({"name": "can.fixture", "type": "page", "comment": "<p><code>can.util.fixture</code> intercepts an AJAX request and simulates\nthe response with a file or function. They are a great technique\nwhen you want to develop JavaScript\nindependently of the backend.</p>\n\n<h2>Types of Fixtures</h2>\n\n<p>There are two common ways of using fixtures.  The first is to\nmap Ajax requests to another file.  The following\nintercepts requests to <code>/tasks.json</code> and directs them\nto <code>fixtures/tasks.json</code>:</p>\n\n<pre><code>can.fixture(\"/tasks.json\", \"fixtures/tasks.json\");\n</code></pre>\n\n<p>The other common option is to generate the Ajax response with\na function.  The following intercepts updating tasks at\n<code>/tasks/ID.json</code> and responds with updated data:</p>\n\n<pre><code>can.fixture(\"PUT /tasks/{id}.json\",\n  function(original, settings, respondWith){\n     respondWith({ updatedAt : new Date().getTime() });\n  })\n</code></pre>\n\n<p>We categorize fixtures into the following types:</p>\n\n<ul>\n<li><strong>Static</strong> - the response is in a file.</li>\n<li><strong>Dynamic</strong> - the response is generated by a function.</li>\n</ul>\n\n<p>There are different ways to lookup static and dynamic fixtures.</p>\n\n<h2>Static Fixtures</h2>\n\n<p>Static fixtures use an alternate url as the response of the Ajax request.</p>\n\n<pre><code>// looks in fixtures/tasks1.json relative to page\ncan.fixture(\"tasks/1\", \"fixtures/task1.json\");\n\n// looks absolute to the page\ncan.fixture(\"tasks/1\", \"//fixtures/task1.json\");\n</code></pre>\n\n<h2>Dynamic Fixtures</h2>\n\n<p>Dynamic Fixtures are functions that get the details of the Ajax request and return the result of the mocked service\nrequest from your server.</p>\n\n<p>For example, the following returns a successful response with JSON data from the server:</p>\n\n<pre><code>can.fixture(\"/foobar.json\",\n  function(original, settings, respondWith){\n    respondWith(200, \"success\", { json: {foo: \"bar\" } }, {})\n  })\n</code></pre>\n\n<p>The fixture function has the following signature:</p>\n\n<pre><code>function( originalOptions, options, respondWith) {\n  respond(status, statusText, responses, responseHeaders);\n}\n</code></pre>\n\n<p>where the fixture function is called with:</p>\n\n<ul>\n<li><code>originalOptions</code> - are the options provided to the ajax method, unmodified,\nand thus, without defaults from ajaxSettings</li>\n<li><code>options</code> - are the request options</li>\n<li><code>respondWith</code> - the response callback. It can be called with:\n<ul><li><code>status</code> - the HTTP status code of the response.</li>\n<li><code>statusText</code> - the status text of the response</li>\n<li><code>responses</code> - a map of dataType/value that contains the responses for each data format supported</li>\n<li><code>responseHeaders</code> - response headers</li></ul></li>\n<li><code>headers</code> - a map of key/value request headers</li>\n</ul>\n\n<p>However, can.fixture handles the common case where you want a successful response with JSON data.\nThe previous can be written like:</p>\n\n<pre><code>can.fixture(\"/foobar.json\",\n  function(original, settings, respondWith){\n    respondWith({ foo: \"bar\" });\n  })\n</code></pre>\n\n<p>Since <code>respondWith</code> is called asynchronously you can also set a custom fixture timeout like this:</p>\n\n<pre><code>can.fixture(\"/foobar.json\",\nfunction(original, settings, respondWith){\n    setTimeout(function() {\n      respondWith({ foo: \"bar\" });\n    }, 1000);\n  })\n</code></pre>\n\n<p>If you want to return an array of data respond like this:</p>\n\n<pre><code>can.fixture(\"/tasks.json\",\n  function(original, settings, respondWith){\n    respondWith([ \"first\", \"second\", \"third\"]);\n  })\n</code></pre>\n\n<p><strong>Note:</strong> A fixture function can also return its response directly like this:</p>\n\n<pre><code>can.fixture(\"/foobar.json\", function(original, settings){\n  return { foo: \"bar\" };\n})\n</code></pre>\n\n<p>This is kept for backwards compatibility and should not be used.</p>\n\n<p>can.fixture works closesly with <a href=\"http://api.jquery.com/extending-ajax/\">jQuery's ajaxTransport</a> system.</p>\n\n<h3>Templated Urls</h3>\n\n<p>Often, you want a dynamic fixture to handle urls for multiple resources (for example a REST url scheme).\ncan.fixture's templated urls allow you to match urls with a wildcard.</p>\n\n<p>The following example simulates services that get and update 100 todos.</p>\n\n<pre><code>// create todos\nvar todos = {};\nfor(var i = 0; i &lt; 100; i++) {\n  todos[i] = {\n    id: i,\n    name: \"Todo \"+i\n  }\n}\ncan.fixture(\"GET /todos/{id}\",\n  function(original, settings, respondWith){\n    // return the JSON data\n    // notice that id is pulled from the url and added to data\n    respondWith(todos[orig.data.id]);\n  })\n\ncan.fixture(\"PUT /todos/{id}\",\n  function(original, settings, respondWith){\n    // update the todo's data\n    can.extend(todos[orig.data.id], orig.data );\n    respondWith({});\n  })\n</code></pre>\n\n<p>Notice that data found in templated urls (ex: <code>{id}</code>) is added to the original data object.</p>\n\n<h2>Simulating Errors</h2>\n\n<p>The following simulates an unauthorized request\nto <code>/foo</code>.</p>\n\n<pre><code>can.fixture(\"/foo\",\n  function(original, settings, respondWith) {\n    respondWith(401,\"{type: 'unauthorized'}\");\n  });\n</code></pre>\n\n<p>This could be received by the following Ajax request:</p>\n\n<pre><code>can.ajax({\n  url: '/foo',\n  error : function(jqXhr, status, statusText){\n    // status === 'error'\n    // statusText === \"{type: 'unauthorized'}\"\n  }\n})\n</code></pre>\n\n<h2>Turning off Fixtures</h2>\n\n<p>You can remove a fixture by passing <code>null</code> for the fixture option:</p>\n\n<pre><code>// add a fixture\ncan.fixture(\"GET todos.json\",\"//fixtures/todos.json\");\n\n// remove the fixture\ncan.fixture(\"GET todos.json\", null)\n</code></pre>\n\n<p>You can also set [can.fixture.on] to false:</p>\n\n<pre><code>can.fixture.on = false;\n</code></pre>\n\n<h2>Make</h2>\n\n<p>[can.fixture.make] makes a CRUD service layer that handles sorting, grouping, filtering and more. Use\nit with a [can.Model] like this:</p>\n\n<pre><code>var Todo = can.Model({\n  findAll : 'GET /todos',\n  findOne : 'GET /todos/{id}',\n  create  : 'POST /todos',\n  update  : 'PUT /todos/{id}',\n  destroy : 'DELETE /todos/{id}'\n  }, {});\n\nvar store = can.fixture.make(100, function(i) {\n  return {\n    id : i,\n    name : 'Todo ' + i\n  }\n});\n\ncan.fixture('GET /todos', store.findAll);\ncan.fixture('GET /todos/{id}', store.findOne);\ncan.fixture('POST /todos', store.create);\ncan.fixture('PUT /todos/{id}', store.update);\ncan.fixture('DELETE /todos/{id}', store.destroy);\n</code></pre>\n\n<h2>Testing Performance</h2>\n\n<p>Dynamic fixtures are awesome for performance testing.  Want to see what\n10000 files does to your app's performance?  Make a fixture that returns 10000 items.</p>\n\n<p>What to see what the app feels like when a request takes 5 seconds to return?  Set\n[can.fixture.delay] to 5000.</p>\n\n<h2>Organizing fixture</h2>\n\n<p>The <strong>best</strong> way of organizing fixtures is to have a 'fixtures.js' file that steals\n<code>can/util/fixture</code> and defines all your fixtures.  For example,\nif you have a 'todo' application, you might\nhave <code>todo/fixtures/fixtures.js</code> look like:</p>\n\n<pre><code>steal({\n        path: '//can/util/fixture.js',\n        ignore: true\n      })\n      .then(function(){\n\n  can.fixture({\n      type: 'get',\n      url: '/services/todos.json'\n    },\n    '//todo/fixtures/todos.json');\n\n  can.fixture({\n      type: 'post',\n      url: '/services/todos.json'\n    },\n    function(original, settings, respondWith){\n        respondWith({\n            id: Math.random(),\n            name: settings.data.name\n        })\n    });\n\n})\n</code></pre>\n\n<p><strong>Notice</strong>: We used steal's ignore option to prevent\nloading the fixture plugin in production.</p>\n\n<p>Finally, we steal <code>todo/fixtures/fixtures.js</code> in the\napp file (<code>todo/todo.js</code>) like:</p>\n\n<pre><code>steal({path: '//todo/fixtures/fixtures.js',ignore: true});\n\n//start of your app's steals\nsteal( ... )\n</code></pre>\n\n<p>We typically keep it a one liner so it's easy to comment out.</p>\n\n<h3>Switching Between Sets of Fixtures</h3>\n\n<p>If you are using fixtures for testing, you often want to use different\nsets of fixtures.  You can add something like the following to your fixtures.js file:</p>\n\n<pre><code>if( /fixtureSet1/.test( window.location.search) ){\n  can.fixture(\"/foo\",\"//foo/fixtures/foo1.json');\n} else if(/fixtureSet2/.test( window.location.search)){\n  can.fixture(\"/foo\",\"//foo/fixtures/foo1.json');\n} else {\n  // default fixtures (maybe no fixtures)\n}\n</code></pre>", "parents": ["can.util"], "src": "can/util/fixture/fixture.md", "children": []})