C({"name": "jQuery.Model", "children": [{"name": "jQuery.Model.static", "shortName": "static", "title": undefined, "hide": false}, {"name": "jQuery.Model.static.find", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.static.wrap", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.static.wrapMany", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.static.id", "shortName": "attribute", "title": undefined, "hide": false}, {"name": "jQuery.Model.static.addAttr", "shortName": "function", "title": undefined, "hide": true}, {"name": "jQuery.Model.static.publish", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.static.guessType", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.static.create", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.static.update", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.static.destroy", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.static._parseDate", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype", "shortName": "prototype", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.init", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.errors", "shortName": "attribute", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.update", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.validate", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.attr", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype._setProperty", "shortName": "function", "title": undefined, "hide": true}, {"name": "jQuery.Model.prototype.attrs", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.isNew", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.save", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.destroy", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.identity", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.elements", "shortName": "function", "title": undefined, "hide": false}, {"name": "jQuery.Model.prototype.publish", "shortName": "function", "title": undefined, "hide": false}], "inherits": "jQuery.Class", "comment": " Models wrap an application's data layer.  In large applications, a model is critical for:\n <ul>\n \t<li>Abstracting service dependencies inside the model, making it so\n      Controllers + Views don't care where data comes from.</li>\n  <li>Providing helper functions that make manipulating and abstracting raw service data much easier.</li>\n </ul>\n This is done in two ways:\n <ul>\n     <li>Requesting data from and <span class='highlight'>interacting with services</span></li>\n     <li><span class='highlight'>Wraping service data</span> with a domain-specific representation</li>\n </ul>\n \n <h2>Using Models</h2>\n \n The [jQuery.Model] class provides basic functionality you need to organize your application's data layer.\n First, let's consider doing Ajax <b>without</b> a model.  In our imaginary app, you:\n <ul>\n   <li>retrieve a list of tasks</li>\n   <li>display the number of days remaining for each task</li>\n   <li>mark tasks as complete after users click them</li>\n </ul>\n Let's see how that might look without a model:\n<pre><code class='javascript'>$.Controller.extend(\"TasksController\",{onDocument: true},\n{\n  load : function(){\n    $.get('/tasks.json', this.callback('gotTasks'), 'json')\n  },\n  /* \n   * assume json is an array like [{name: \"trash\", due_date: 1247111409283}, ...]\n   */\n  gotTasks : function(json){ \n    for(var i =0; i < json.length; i++){\n      var taskJson = json[i];\n      //calculate time remaining\n      var time_remaining = new Date() - new Date(taskJson.due_date);\n      //append some html\n      this.element.append(\"&lt;div class='task' taskid='\"+taskJson.id+\"'>\"+\n\t                     \"&lt;label>\"+taskJson.name+\"&lt;/label>\"+\n\t                     \"Due Date = \"+time_remaining+\"&lt;/div>\")\n\t}\n  },\n  click : function(el){\n    $.post('/task_complete',{id: el.attr('taskid')}, function(){\n      el.remove();\n    })\n  }\n})</code></pre>This code might seem fine for right now, but what if:\n<ul>\n\t<li>The service changes?</li>\n\t<li>You want to use the remaining time for other uses?</li>\n\t<li>Multiple elements have the same data?</li>\n</ul>\nThe solution is of course a strong model layer.  Lets look at what a\na good model does for a controller before we learn how to make one.  I've highlighted\nsome of the key functionality we need to build:\n<pre><code class='javascript'>$.Controller.extend(\"TasksController\",{onDocument: true},\n{\n\tload : function(){\n\t  <b>Task.findAll</b>({},this.callback('list'))\n\t},\n\tlist : function(tasks){\n\t  this.render({data: {tasks: tasks}});\n\t},\n\tclick : function(el){\n        <b>el.models</b>()[0].<b>complete</b>(function(){\n          el.remove();\n      });\n\t}\n})</code></pre>In views/tasks/list.ejs\n<pre><code class='html'>&lt;% for(var i =0; i &lt; tasks.length; i++){ %>\n&lt;div class='task &lt;%= tasks[i].<b>identity</b>() %>'>\n   &lt;label>&lt;%= tasks[i].name %>&lt;/label>\n   &lt;%= tasks[i].<b>timeRemaining</b>() %>\n&lt;/div>\n&lt;% } %></code></pre>\nIsn't that better!  Granted, some of the improvement comes because we used a view, but we've\nalso made our controller completely understandable.  Now lets take a look at the model:\n<pre><code class='javascript'>$.Model.extend(\"Task\",\n{\n    findAll : function(params,success){\n        $.get(\"/tasks.json\", params, this.callback([\"wrapMany\",success]),\"json\");\n    }\n},\n{\n    timeRemaining : function(){\n        return new Date() - new Date(this.due_date)\n    },\n    complete : function(success){\n        $.get(\"/task_complete\", {id: this.id }, success,\"json\");\n    }\n})</code></pre>There, much better!  Now you have a single place where you can organize Ajax functionality and\nwrap the data that it returned.  Lets go through each bolded item in the controller and view.<br/>\n\n<h3>Task.findAll</h3>\nThe findAll function requests data from \"/tasks.json\".  When the data is returned, it it is run through\nthe \"wrapMany\" function before being passed to the success callback.<br/>\nIf you don't understand how the callback works, you might want to check out \n[jQuery.Model.static.wrapMany wrapMany] and [jQuery.Class.static.callback callback].\n<h3>el.models</h3>\n[jQuery.fn.models models] is a jQuery helper that returns model instances.  It uses\nthe jQuery's elements' shortNames to find matching model instances.  For example:\n<pre><code class='html'>&lt;div class='task task_5'> ... &lt;/div></code></pre>It knows to return a task with id = 5.\n<h3>complete</h3>\nThis should be pretty obvious.\n<h3>identity</h3>\n[jQuery.Model.prototype.identity Identity] returns a unique identifier that [jQuery.fn.models] can use\nto retrieve your model instance.\n<h3>timeRemaining</h3>\ntimeRemaining is a good example of wrapping your model's raw data with more useful functionality.\n<h2>Validations</h2>\nYou can validate your model's attributes with another plugin.  See [validation].\n \n", "shortName": "Class", "tags": ["core"]})