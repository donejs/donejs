<!DOCTYPE html>

<!--[if lt IE 7]>
<html class="no-js ie lt-ie9 lt-ie8 lt-ie7" lang="en">
<![endif]-->
<!--[if IE 7]>
<html class="no-js ie lt-ie9 lt-ie8" lang="en">
<![endif]-->
<!--[if IE 8]>
<html class="no-js ie lt-ie9" lang="en">
<![endif]-->
<!--[if IE 9]>
<html class="no-js ie ie9" lang="en">
<![endif]-->
<!--[if gt IE 9]><!-->
<html class="no-js" lang="en">
<!--<![endif]-->
<head>
	<meta charset="utf-8">
  <title>donejs - In-depth guide</title>
	<meta property="og:title" content="donejs - In-depth guide">
	<meta property="og:description" content="In this guide you will learn about all of DoneJS&#x27; features by creating, testing, documenting, building and deploying place-my-order.com, a restaurant menu and ordering application. The final result will look like this:  After the initial application setup, which includes a server that hosts and pre-renders the application, we will create several custom elements and bring them together using the application state and routes. Then we will learn how to retrieve data from the server using a RESTful API. After that we will talk about what a view model is and how to identify, implement and test its functionality. Once we have unit tests running in the browser, we will automate running them locally from the command line and also on a continuous integration server. In the subsequent chapters, we will show how to easily import other modules into our application and how to set up a real-time connection. Finally, we will describe how to build and deploy our application to the web, as a desktop application with Electron, and as a mobile app with Cordova.">
  <meta property="og:image" content="https://www.bitovi.com/hubfs/open-source/os-donejs.jpg">
	<meta name="google-site-verification" content="-E1_on_BhUFqVXxNgtGgNYF5FIJojlOksLPK8zdeiL8" />
	<meta name="description" content="In this guide you will learn about all of DoneJS&#x27; features by creating, testing, documenting, building and deploying place-my-order.com, a restaurant menu and ordering application. The final result will look like this:  After the initial application setup, which includes a server that hosts and pre-renders the application, we will create several custom elements and bring them together using the application state and routes. Then we will learn how to retrieve data from the server using a RESTful API. After that we will talk about what a view model is and how to identify, implement and test its functionality. Once we have unit tests running in the browser, we will automate running them locally from the command line and also on a continuous integration server. In the subsequent chapters, we will show how to easily import other modules into our application and how to set up a real-time connection. Finally, we will describe how to build and deploy our application to the web, as a desktop application with Electron, and as a mobile app with Cordova.">
	<meta name="author" content="Bitovi - DoneJS">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
  <script type="application/ld+json">
		{
			"@context": "http://www.schema.org",
			"@type": "SoftwareSourceCode",
			"applicationCategory": "DeveloperApplication",
			"brand": "Bitovi",
			"category": "JavaScript Frameworks",
			"codeRepository": "https://github.com/donejs/donejs",
			"description": "In this guide you will learn about all of DoneJS&#x27; features by creating, testing, documenting, building and deploying place-my-order.com, a restaurant menu and ordering application. The final result will look like this:  After the initial application setup, which includes a server that hosts and pre-renders the application, we will create several custom elements and bring them together using the application state and routes. Then we will learn how to retrieve data from the server using a RESTful API. After that we will talk about what a view model is and how to identify, implement and test its functionality. Once we have unit tests running in the browser, we will automate running them locally from the command line and also on a continuous integration server. In the subsequent chapters, we will show how to easily import other modules into our application and how to set up a real-time connection. Finally, we will describe how to build and deploy our application to the web, as a desktop application with Electron, and as a mobile app with Cordova.",
			"image": "https://www.bitovi.com/hubfs/open-source/os-donejs.jpg",
			"license": "https://github.com/donejs/donejs/blob/master/license.md",
			"logo": "https://www.bitovi.com/hubfs/open-source/os-donejs.jpg",
			"name": "DoneJS - In-depth guide",
			"programmingLanguage": "JavaScript"
		}
	</script>
	<link rel="apple-touch-icon" sizes="57x57" href="static/img/favicons/apple-touch-icon-57x57.png">
	<link rel="apple-touch-icon" sizes="60x60" href="static/img/favicons/apple-touch-icon-60x60.png">
	<link rel="apple-touch-icon" sizes="72x72" href="static/img/favicons/apple-touch-icon-72x72.png">
	<link rel="apple-touch-icon" sizes="76x76" href="static/img/favicons/apple-touch-icon-76x76.png">
	<link rel="apple-touch-icon" sizes="114x114" href="static/img/favicons/apple-touch-icon-114x114.png">
	<link rel="apple-touch-icon" sizes="120x120" href="static/img/favicons/apple-touch-icon-120x120.png">
	<link rel="apple-touch-icon" sizes="144x144" href="static/img/favicons/apple-touch-icon-144x144.png">
	<link rel="apple-touch-icon" sizes="152x152" href="static/img/favicons/apple-touch-icon-152x152.png">
	<link rel="apple-touch-icon" sizes="180x180" href="static/img/favicons/apple-touch-icon-180x180.png">
	<link rel="icon" type="image/png" href="static/img/favicons/favicon-32x32.png" sizes="32x32">
	<link rel="icon" type="image/png" href="static/img/favicons/android-chrome-192x192.png" sizes="192x192">
	<link rel="icon" type="image/png" href="static/img/favicons/favicon-96x96.png" sizes="96x96">
	<link rel="icon" type="image/png" href="static/img/favicons/favicon-16x16.png" sizes="16x16">
	
		<link rel="stylesheet" type="text/css" href="./static/bundles/bit-docs-site/static.css">
	
	<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">
</head>
<body class="docs place-my-order">
		<div id="greyOutUnderNav" style="display:none;"></div>
		<header>
			<nav class="navbar navbar-default navbar-fixed-top">
				<div class="container">
					<!-- Brand and toggle get grouped for betteor mobile display -->
					<div class="navbar-header">
						<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
							<span class="sr-only">Toggle navigation</span>
							<span class="mobile-menu-label">MENU</span>
							<span class="mobile-menu-close"></span>
						</button>
						<div class="logo-menu">
							<a class="brand" href="./index.html">DoneJS</a>
							<ul class="dropdown-menu hidden-xs">
								<li><a href="https://donejs.com" class="active">DoneJS</a></li>
								<li><a href="https://canjs.com">CanJS</a></li>
								<li><a href="https://stealjs.com">StealJS</a></li>
								<li><a href="https://jquerypp.com">jQuery++</a></li>
								<li><a href="https://funcunit.com">FuncUnit</a></li>
								<li><a href="https://documentjs.com">DocumentJS</a></li>
							</ul>
						</div>
					</div>
					<div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
						<ul class="nav navbar-nav">
							<li ><a href="./index.html">Home</a></li>
							<li ><a href="./Features.html">Features</a></li>
							<li ><a href="./About.html">About</a></li>
							<li ><a href="./Apis.html">Apis</a></li>

							<li class="guides-menu">
								<a href="./Guides.html">Guides</a>
								<ul class="dropdown-menu">
									<li><a href="./SettingUp.html">Setting Up</a></li>
									<li><a href="./Guide.html">Quick Start</a></li>
									<li><a href="./place-my-order.html">In-depth</a></li>
									<li><a href="./plugin.html">Creating a plugin</a></li>
									<li><a href="./generator.html">Creating a generator</a></li>
									<li><a href="./bitballs.html">Example App: Bitballs</a></li>
                  <li><a href="./ssr-react.html">Server rendering React</a></li>
									<li><a href="./migrate-1.html">Migrate to DoneJS 1</a></li>
                  <li><a href="./migrate-2.html">Migrate to DoneJS 2</a></li>
                  <li><a href="./migrate-3.html">Migrate to DoneJS 3</a></li>
                  <li><a href="./updating-deps.html">Updating Dependencies</a></li>
									<li><a href="./contributing.html">Contributing</a></li>
								</ul>
							</li>

							<li >
								<a href="./community.html">Community</a>
							</li>
						</ul>

						<ul class="nav navbar-nav navbar-right bitovi-menu">
							<li class="dropdown">
								<a href="https://www.bitovi.com" class="bitovi icon-bits">Bitovi</a>
								<ul class="dropdown-menu">
									<li><a href="https://www.bitovi.com/">Bitovi.com</a></li>
									<li><a href="https://www.bitovi.com/blog">Blog</a></li>
									<li><a href="https://www.bitovi.com/design">Design</a></li>
									<li><a href="https://www.bitovi.com/development">Development</a></li>
									<li><a href="https://www.bitovi.com/training">Training</a></li>
									<li><a href="https://www.bitovi.com/open-source">Open Source</a></li>
									<li><a href="https://www.bitovi.com/about">About</a></li>
									<li><a href="https://www.bitovi.com/contact">Contact Us</a></li>
								</ul>
							</li>
						</ul>
						<ul class="menu-lib-logos hidden-sm hidden-md hidden-lg">
							<li>
								<a href="#">
									<img class="logo-canjs" src="static/img/lib-logos/canjs_logo.svg" />
									<span class="logo-label">CanJS</span>
								</a>
							</li>
							<li>
								<a href="#">
									<img class="logo-stealjs" src="static/img/lib-logos/stealjs-logo.svg" />
									<span class="logo-label">StealJS</span>
								</a>
							</li>
							<li>
								<a href="#">
									<img class="logo-jqueryplus" src="static/img/lib-logos/jquery-plusplus-logo.svg" />
									<span class="logo-label">jQuery++</span>
								</a>
							</li>
							<li>
								<a href="#">
									<img class="logo-funcunit" src="static/img/lib-logos/funcunit-logo.svg" />
									<span class="logo-label">FuncUnit</span>
								</a>
							</li>
							<li>
								<a href="#">
									<img class="logo-docjs" src="static/img/lib-logos/documentjs-logo.svg" />
									<span class="logo-label">DocumentJS</span>
								</a>
							</li>
						</ul>

					</div>
				</div>
			</nav>
		</header>

	<div class="scroll-spy-title hidden-md hidden-lg">
    <span class="menu-indicator menus-closed"></span>
		<div id="scrollSpyCurrentH2" class="h2Only">Table of Contents</div>
		<div id="scrollSpyCurrentH3"></div>
	</div>
	

	
	<div class="container-fluid api">
		<div class="row">
	
		

		
		<article class="content docs col-xs-12 ">
		

			
			<section class="title">
				<div class="heading">
<h1>In-depth guide</h1>
	<ul class="tags">
		<li>page</li>
	</ul>
	
	
</div>

<div class="sub-heading">
	
	
		<span class="module">place-my-order</span>
	
	
	
	<span class="inherits">&nbsp;</span>
</div>

<ul class="links">
	
	
	
</ul>
<br />

			</section>
			

      
      <section
        class="contents on-this-page-container"
        data-headings-container-selector=".content .comment"
        >
      </section>
      

			

			
			<section class="description">
				<p>In this guide you will learn about all of <a href="./Features.html">DoneJS' features</a> by creating, testing, documenting, building and deploying <a href="http://www.place-my-order.com">place-my-order.com</a>, a restaurant menu and ordering application. The final result will look like this:</p>
<p><img src="static/img/place-my-order.png" srcset="static/img/place-my-order.png 1x, static/img/place-my-order-2x.png 2x"></p>
<p>After the initial application setup, which includes a server that hosts and pre-renders the application, we will create several custom elements and bring them together using the application state and routes. Then we will learn how to retrieve data from the server using a RESTful API.</p>
<p>After that we will talk about what a view model is and how to identify, implement and test its functionality. Once we have unit tests running in the browser, we will automate running them locally from the command line and also on a continuous integration server. In the subsequent chapters, we will show how to easily import other modules into our application and how to set up a real-time connection.</p>
<p>Finally, we will describe how to build and deploy our application to the web, as a desktop application with Electron, and as a mobile app with Cordova.</p>

			</section>
			

			
				
			

			


			
			<section class="comment">
				<h2>Set up the project</h2>
<p>In this section we will create our DoneJS project and set up a RESTful API for the application to use.
You will need <a href="http://nodejs.org">NodeJS</a> installed and your code editor of choice.</p>
<blockquote>
<p>If you haven't already, check out the <a href="SettingUp.html" title="This page contains information on setting up DoneJS. It will walk you through getting prerequisites needed before you ever install DoneJS and includes platform-specific pieces of information not covered in the Quick Start or In Depth guides.
DoneJS officially supports:

Node 10 and up
npm 6.x and up">Setting Up DoneJS</a> guide to ensure you have all of the prerequisites installed and configured.</p>
</blockquote>
<h3>Create the project</h3>
<p>To get started, let's install the DoneJS command line utility globally:</p>
<pre><code class="language-shell">npm install -g donejs@3
</code></pre>
<p>Then we can create a new DoneJS application:</p>
<pre><code class="language-shell">donejs add app place-my-order --yes
</code></pre>
<p>The initialization process will ask you questions like the name of your application (set to <code>place-my-order</code>) and the source folder (set to <code>src</code>). The other questions can be skipped by hitting enter. This will install all of DoneJS' dependencies. The main project dependencies include:</p>
<ul>
<li><a href="https://stealjs.com">StealJS</a> - ES6, CJS, and AMD module loader and builder</li>
<li><a href="https://canjs.com">CanJS</a> - Custom elements and Model-View-ViewModel utilities</li>
<li><a href="https://github.com/donejs/done-ssr">done-ssr</a> - Server-rendering</li>
<li><a href="https://qunitjs.com/">QUnit</a> or Mocha - Assertion library</li>
<li><a href="https://funcunit.com">FuncUnit</a> - Functional tests</li>
<li><a href="https://github.com/bitovi/testee">Testee</a> - Test runner</li>
</ul>
<p>If we now go into the <code>place-my-order</code> folder with</p>
<pre><code class="language-shell">cd place-my-order
</code></pre>
<p>We can see the following files:</p>
<pre><code class="language-shell">├── build.js
├── development.html
├── package.json
├── production.html
├── README.md
├── test.html
├── src/
|   ├── app.js
|   ├── index.stache
|   ├── is-dev.js
|   ├── models/
|   |   ├── fixtures
|   |   |   ├── fixtures.js
|   |   ├── test.js
|   ├── styles.less
|   ├── test.js
├── node_modules/
</code></pre>
<p>Let's have a quick look at the purpose of each:</p>
<ul>
<li><a href="https://github.com/donejs/generator-donejs#developmenthtml"><code>development.html</code></a>, <a href="https://github.com/donejs/generator-donejs#productionhtml"><code>production.html</code></a> those pages can run the DoneJS application in development or production mode without a server.</li>
<li><code>package.json</code> is the main configuration file that defines all our application dependencies and other settings.</li>
<li><code>test.html</code> is used to run all our tests.</li>
<li><code>README.md</code> is the readme file for your repository.</li>
<li><code>src</code> is the folder where all our development assets live in their own modlets (more about that later).</li>
<li><code>src/app.js</code> is the main application file, which exports the main application state.</li>
<li><code>src/index.stache</code> is the main client template that includes server-side rendering.</li>
<li><code>src/is-dev.js</code> is used to conditional load modules in development-mode only.</li>
<li><code>src/models/</code> is the folder where models for the API connection will be put. It currently contains <code>fixtures/fixtures.js</code> which will reference all the specific models fixtures files (so that we can run model tests without the need for a running API server) and <code>test.js</code> which will later gather all the individual model test files.</li>
<li><code>src/styles.less</code> is the main application styles.</li>
<li><code>src/test.js</code> collects all individual component and model tests we will create throughout this guide as well as the functional smoke test for our application and is loaded by <code>test.html</code>.</li>
</ul>
<h3>Development mode</h3>
<p>DoneJS comes with its own server, which hosts your development files and takes care of server-side rendering. DoneJS' development mode will also enable <a href="http://blog.bitovi.com/hot-module-replacement-comes-to-stealjs/">hot module swapping</a> which automatically reloads files in the browser as they change. You can start it by running:</p>
<pre><code class="language-shell">donejs develop
</code></pre>
<p>The default port is 8080, so if we now go to <a href="http://localhost:8080/" title="http://localhost:8080/">http://localhost:8080/</a> we can see our application with a default homepage. If we change <code>src/index.stache</code> or <code>src/app.js</code> all changes will show up right away in the browser. Try it by adding some HTML in <code>src/index.stache</code>.</p>
<h3>Setup a service API</h3>
<p>Single page applications often communicate with a RESTful API and a <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">WebSocket connection</a> for real-time updates. This guide will not cover how to create a REST API. Instead, we'll just install and start an existing service API created specifically for use with this tutorial:</p>
<p><strong>Note</strong>: Kill the server for now while we install a few dependencies (ctrl+c on Windows and Mac).</p>
<pre><code class="language-shell">npm install place-my-order-api@1 --save
</code></pre>
<p>Now we can add an API server start script into the <code>scripts</code> section of our <code>package.json</code> like this:</p>
<pre><code class="language-js">  &quot;scripts&quot;: {
    &quot;api&quot;: &quot;place-my-order-api --port 7070&quot;,
    &quot;test&quot;: &quot;testee test.html --browsers firefox --reporter Spec&quot;,
    &quot;start&quot;: &quot;done-serve --port 8080&quot;,
    &quot;develop&quot;: &quot;done-serve --develop --port 8080&quot;,
    &quot;build&quot;: &quot;node build&quot;
  },
</code></pre>
<div line-highlight='2,2,only'></div>
<p>Which allows us to start the server like:</p>
<pre><code class="language-shell">donejs api
</code></pre>
<p>The first time it starts, the server will initialize some default data (restaurants and orders). Once started, you can verify that the data has been created and the service is running by going to <a href="http://localhost:7070/restaurants">http://localhost:7070/restaurants</a>, where we can see a JSON list of restaurant data.</p>
<h3>Starting the application</h3>
<p>Now our application is good to go and we can start the server. We need to proxy the <code>place-my-order-api</code> server to <code>/api</code> on our server in order to avoid violating the <a href="https://en.wikipedia.org/wiki/Same-origin_policy">same origin policy</a>. This means that we need to modify the <code>start</code> and <code>develop</code> script in our <code>package.json</code> to:</p>
<pre><code class="language-js">&quot;scripts&quot;: {
  &quot;api&quot;: &quot;place-my-order-api --port 7070&quot;,
  &quot;test&quot;: &quot;testee test.html --browsers firefox --reporter Spec&quot;,
  &quot;start&quot;: &quot;done-serve --proxy http://localhost:7070 --port 8080&quot;,
  &quot;develop&quot;: &quot;done-serve --develop --proxy http://localhost:7070 --port 8080&quot;,
  &quot;build&quot;: &quot;node build&quot;
},
</code></pre>
<div line-highlight='4,5,only'></div>
<p>Now we can start the application with:</p>
<pre><code class="language-shell">donejs develop
</code></pre>
<p>Go to <a href="http://localhost:8080">http://localhost:8080</a> to see the &quot;hello world&quot; message again.</p>
<h3>Loading assets</h3>
<p>Before we get to the code, we also need to install the <code>place-my-order-assets</code> package which contains the images and styles specifically for this tutorial's application:</p>
<pre><code class="language-shell">npm install place-my-order-assets@0.1 --save
</code></pre>
<p>Every DoneJS application consists of at least two files:</p>
<ol>
<li><strong>A main template</strong> (in this case <code>src/index.stache</code>) which contains the main template and links to the development or production assets.</li>
<li><strong>A main application view-model</strong> (<code>src/app.js</code>) that initializes the application state and routes.</li>
</ol>
<p><code>src/index.stache</code> was already created for us when we ran <code>donejs add app</code>, so update it to
load the static assets and set a <code>&lt;meta&gt;</code> tag to support a responsive design:</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{this.title}}&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;minimal-ui, width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;can-import from=&quot;place-my-order-assets&quot; /&gt;
    &lt;can-import from=&quot;~/styles.less&quot; /&gt;
    &lt;can-import from=&quot;~/app&quot; export-as=&quot;viewModel&quot; route-data=&quot;routeData&quot; /&gt;

    &lt;h1&gt;The &lt;strong&gt;{{this.routeData.page}}&lt;/strong&gt; page&lt;/h1&gt;

    {{#eq(this.env.NODE_ENV, &quot;production&quot;)}}
      &lt;script src=&quot;{{joinBase('steal.production.js')}}&quot;&gt;&lt;/script&gt;
    {{else}}
      &lt;script src=&quot;/node_modules/steal/steal.js&quot; main&gt;&lt;/script&gt;
    {{/eq}}
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<div line-highlight='4,7,only'></div>
<p>This is an HTML5 template that uses <a href="https://canjs.com/doc/can-stache.html">can-stache</a> - a <a href="http://handlebarsjs.com/">Handlebars syntax</a>-compatible view engine. It renders a <code>message</code> property from the application state.</p>
<p><code>can-import</code> loads the template's dependencies:</p>
<ol>
<li>The <code>place-my-order-assets</code> package, which loads the LESS styles for the application</li>
<li><code>place-my-order/app</code>, which is the main application file</li>
</ol>
<p>The main application file at <code>src/app.js</code> looks like this:</p>
<pre><code class="language-js">// src/app.js
import { DefineMap, route } from 'can';
import RoutePushstate from 'can-route-pushstate';
import debug from 'can-debug#?./is-dev';

//!steal-remove-start
if(debug) {
    debug();
}
//!steal-remove-end

const AppViewModel = DefineMap.extend(&quot;AppViewModel&quot;, {
  env: {
    default: () =&gt; ({NODE_ENV:'development'})
  },
  title: {
    default: 'place-my-order'
  },
  routeData: {
    default: () =&gt; route.data
  }
});

route.urlData = new RoutePushstate();
route.register(&quot;{page}&quot;, { page: &quot;home&quot; });

export default AppViewModel;

</code></pre>
<p>This initializes a <a href="https://canjs.com/doc/can-define/map/map.html">DefineMap</a>: a special object that acts as the application global state (with a default <code>message</code> property) and also plays a key role in enabling server side rendering.</p>
<h2>Creating custom elements</h2>
<p>One of the most important concepts in DoneJS is splitting up your application functionality into individual, self-contained modules. In the following section we will create separate components for the homepage, the restaurant list, and the order history page. After that, we will glue them all together using routes and the global application state.</p>
<p>There are two ways of creating components. For smaller components we can define all templates, styles and functionality in a single <code>.component</code> file (to learn more see <a href="https://github.com/donejs/done-component">done-component</a>). Larger components can be split up into several separate files.</p>
<h3>Creating a homepage element</h3>
<p>To generate a new component run:</p>
<pre><code class="language-shell">donejs add component pages/home.component pmo-home
</code></pre>
<p>This will create a file at <code>src/pages/home.component</code> containing the basic ingredients of a component. We will update it to reflect the below content:</p>
<pre><code class="language-html">&lt;can-component tag=&quot;pmo-home&quot;&gt;
  &lt;style type=&quot;less&quot;&gt;
    display: block;

    p { font-weight: bold; }
  &lt;/style&gt;
  &lt;view&gt;
    &lt;can-import from=&quot;can-stache-route-helpers&quot; /&gt;
    &lt;div class=&quot;homepage&quot;&gt;
      &lt;img src=&quot;{{joinBase('node_modules/place-my-order-assets/images/homepage-hero.jpg')}}&quot;
          alt=&quot;Restaurant table with glasses.&quot; width=&quot;250&quot; height=&quot;380&quot; /&gt;
      &lt;h1&gt;Ordering food has never been easier&lt;/h1&gt;
      &lt;p&gt;
        We make it easier than ever to order gourmet food
        from your favorite local restaurants.
      &lt;/p&gt;
      &lt;p&gt;
        &lt;a class=&quot;btn&quot; href=&quot;{{routeUrl(page='restaurants')}}&quot; role=&quot;button&quot;&gt;Choose a Restaurant&lt;/a&gt;
      &lt;/p&gt;
    &lt;/div&gt;
  &lt;/view&gt;
  &lt;script type=&quot;view-model&quot;&gt;
    import { DefineMap } from 'can';

    export default DefineMap.extend(&quot;PmoHomeVM&quot;, {
      // EXTERNAL STATEFUL PROPERTIES
      // These properties are passed from another component. Example:
      // value: {type: &quot;number&quot;}

      // INTERNAL STATEFUL PROPERTIES
      // These properties are owned by this component.
      message: { default: &quot;This is the pmo-home component&quot; },

      // DERIVED PROPERTIES
      // These properties combine other property values. Example:
      // get valueAndMessage(){ return this.value + this.message; }

      // METHODS
      // Functions that can be called by the view. Example:
      // incrementValue() { this.value++; }

      // SIDE EFFECTS
      // The following is a good place to perform changes to the DOM
      // or do things that don't fit in to one of the areas above.
      connectedCallback(element){

      }
    });
  &lt;/script&gt;
&lt;/can-component&gt;

</code></pre>
<div line-highlight='8-20,only'></div>
<p>Here we created a <a href="https://canjs.com/doc/can-component.html">can-component</a> named <code>pmo-home</code>. This particular component is just a basic template, it does not have much in the way of styles or functionality.</p>
<h3>Create the order history element</h3>
<p>We'll create an initial version of order history that is very similar.</p>
<pre><code class="language-shell">donejs add component pages/order/history.component pmo-order-history
</code></pre>
<p>And update <code>src/pages/order/history.component</code>:</p>
<pre><code class="language-html">&lt;can-component tag=&quot;pmo-order-history&quot;&gt;
  &lt;style type=&quot;less&quot;&gt;
    display: block;

    p { font-weight: bold; }
  &lt;/style&gt;
  &lt;view&gt;
    &lt;div class=&quot;order-history&quot;&gt;
      &lt;div class=&quot;order header&quot;&gt;
        &lt;address&gt;Name / Address / Phone&lt;/address&gt;
        &lt;div class=&quot;items&quot;&gt;Order&lt;/div&gt;
        &lt;div class=&quot;total&quot;&gt;Total&lt;/div&gt;
        &lt;div class=&quot;actions&quot;&gt;Action&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/view&gt;
  &lt;script type=&quot;view-model&quot;&gt;
    import { DefineMap } from 'can';

    export default DefineMap.extend(&quot;PmoOrderHistoryVM&quot;, {
      // EXTERNAL STATEFUL PROPERTIES
      // These properties are passed from another component. Example:
      // value: {type: &quot;number&quot;}

      // INTERNAL STATEFUL PROPERTIES
      // These properties are owned by this component.
      message: { default: &quot;This is the pmo-order-history component&quot; },

      // DERIVED PROPERTIES
      // These properties combine other property values. Example:
      // get valueAndMessage(){ return this.value + this.message; }

      // METHODS
      // Functions that can be called by the view. Example:
      // incrementValue() { this.value++; }

      // SIDE EFFECTS
      // The following is a good place to perform changes to the DOM
      // or do things that don't fit in to one of the areas above.
      connectedCallback(element){

      }
    });
  &lt;/script&gt;
&lt;/can-component&gt;

</code></pre>
<div line-highlight='8-15,only'></div>
<h3>Creating a restaurant list element</h3>
<p>The restaurant list will contain more functionality, which is why we will split its template and component logic into separate files.</p>
<p>We can create a basic component like that by running:</p>
<pre><code class="language-shell">donejs add component pages/restaurant/list pmo-restaurant-list
</code></pre>
<p>The component's files are collected in a single folder so that components can be easily tested, moved, and re-used. The folder structure looks like this:</p>
<pre><code class="language-shell">├── node_modules
├── package.json
├── src/
|   ├── app.js
|   ├── index.md
|   ├── index.stache
|   ├── test.js
|   ├── models
|   ├── pages/
|   |   ├── order/
|   |   |   ├── history.component
|   |   ├── restaurant/
|   |   |   ├── list/
|   |   |   |   ├── list.html
|   |   |   |   ├── list.js
|   |   |   |   ├── list.less
|   |   |   |   ├── list.md
|   |   |   |   ├── list.stache
|   |   |   |   ├── list-test.js
|   |   |   |   ├── test.html
</code></pre>
<p>We will learn more about those files and add more functionality to this element later, but it already contains a fully functional component with a demo page (see <a href="http://localhost:8080/src/pages/restaurant/list/list.html">localhost:8080/src/pages/restaurant/list/list.html</a>), a basic test (at <a href="http://localhost:8080/src/pages/restaurant/list/test.html">localhost:8080/src/pages/restaurant/list/test.html</a>) and documentation placeholders.</p>
<h2>Setting up routing</h2>
<p>In this part, we will create routes - URL patterns that load specific parts of our single page app. We'll also dynamically load the custom elements we created and integrate them in the application's main page.</p>
<h3>Create Routes</h3>
<p>Routing works a bit differently than other libraries. In other libraries, you might declare routes and map those to controller-like actions.</p>
<p>DoneJS application <a href="https://canjs.com/doc/can-route.html">routes</a> map URL strings (like /user/1) to properties in our application state. In other words, our routes will just be a representation of the application state.</p>
<p>To learn more about routing visit the <a href="https://canjs.com/doc/guides/routing.html">CanJS routing guide</a>.</p>
<p>To add our routes, change <code>src/app.js</code> to:</p>
<pre><code class="language-js">import { DefineMap, route } from 'can';
import RoutePushstate from 'can-route-pushstate';
import debug from 'can-debug#?./is-dev';

//!steal-remove-start
if(debug) {
    debug();
}
//!steal-remove-end

const AppViewModel = DefineMap.extend(&quot;AppViewModel&quot;, {
  page: 'string',
  slug: 'string',
  action: 'string',
  env: {
    default: () =&gt; ({NODE_ENV:'development'})
  },
  title: {
    default: 'place-my-order'
  },
  routeData: {
    default: () =&gt; route.data
  }
});

route.urlData = new RoutePushstate();
route.register(&quot;{page}&quot;, { page: &quot;home&quot; });
route.register('{page}/{slug}', { slug: null });
route.register('{page}/{slug}/{action}', { slug: null, action: null });

export default AppViewModel;

</code></pre>
<div line-highlight='12-14,28-29,only'></div>
<p>Now we have three routes available:</p>
<ul>
<li><code>{page}</code> captures urls like <a href="http://localhost:8080/home">http://localhost:8080/home</a> and sets the <code>page</code> property on <code>routeData</code> to <code>home</code> (which is also the default when visiting <a href="http://localhost:8080/">http://localhost:8080/</a>)</li>
<li><code>{page}/{slug}</code> matches restaurant links like <a href="http://localhost:8080/restaurants/spago">http://localhost:8080/restaurants/spago</a> and sets <code>page</code> and <code>slug</code> (a URL friendly restaurant short name)</li>
<li><code>{page}/{slug}/{action}</code> will be used to show the order page for a specific restaurant e.g. <a href="http://localhost:8080/restaurants/spago/order">http://localhost:8080/restaurants/spago/order</a></li>
</ul>
<h3>Adding a header element</h3>
<p>Now is also a good time to add a header element that links to the different routes we just defined. We can run</p>
<pre><code class="language-shell">donejs add component components/header.component pmo-header
</code></pre>
<p>and update <code>src/components/header.component</code> to:</p>
<pre><code class="language-html">&lt;can-component tag=&quot;pmo-header&quot;&gt;
  &lt;style type=&quot;less&quot;&gt;
    display: block;

    p { font-weight: bold; }
  &lt;/style&gt;
  &lt;view&gt;
    &lt;can-import from=&quot;can-stache-route-helpers&quot; /&gt;
    &lt;header&gt;
      &lt;nav&gt;
       &lt;h1&gt;place-my-order.com&lt;/h1&gt;
       &lt;ul&gt;
         &lt;li class=&quot;{{#eq(this.page, 'home')}}active{{/eq}}&quot;&gt;
           &lt;a href=&quot;{{routeUrl(page='home')}}&quot;&gt;Home&lt;/a&gt;
         &lt;/li&gt;
         &lt;li class=&quot;{{#eq(this.page, 'restaurants')}}active{{/eq}}&quot;&gt;
           &lt;a href=&quot;{{routeUrl(page='restaurants')}}&quot;&gt;Restaurants&lt;/a&gt;
         &lt;/li&gt;
         &lt;li class=&quot;{{#eq(this.page, 'order-history')}}active{{/eq}}&quot;&gt;
           &lt;a href=&quot;{{routeUrl(page='order-history')}}&quot;&gt;Order History&lt;/a&gt;
         &lt;/li&gt;
       &lt;/ul&gt;
      &lt;/nav&gt;
    &lt;/header&gt;
  &lt;/view&gt;
  &lt;script type=&quot;view-model&quot;&gt;
    import { DefineMap } from 'can';

    export default DefineMap.extend(&quot;PmoHeaderVM&quot;, {
      // EXTERNAL STATEFUL PROPERTIES
      // These properties are passed from another component. Example:
      // value: {type: &quot;number&quot;}
      page: &quot;string&quot;,

      // INTERNAL STATEFUL PROPERTIES
      // These properties are owned by this component.
      message: { default: &quot;This is the pmo-header component&quot; },

      // DERIVED PROPERTIES
      // These properties combine other property values. Example:
      // get valueAndMessage(){ return this.value + this.message; }

      // METHODS
      // Functions that can be called by the view. Example:
      // incrementValue() { this.value++; }

      // SIDE EFFECTS
      // The following is a good place to perform changes to the DOM
      // or do things that don't fit in to one of the areas above.
      connectedCallback(element){

      }
    });
  &lt;/script&gt;
&lt;/can-component&gt;

</code></pre>
<div line-highlight='8-24,33,only'></div>
<p>Here we use <a href="https://canjs.com/doc/can-stache.helpers.routeUrl.html">routeUrl</a> to create links that will set values in the application state. For example, the first usage of routeUrl above will create a link based on the current routing rules (<a href="http://localhost:8080/home">http://localhost:8080/home</a> in this case) that sets the <code>page</code> property to <code>home</code> when clicked.</p>
<p>We also use the Stache <code>eq</code> helper to make the appropriate link active.</p>
<h3>Switch between components</h3>
<p>Now we can glue all those individual components together. What we want to do is - based on the current page (<code>home</code>, <code>restaurants</code> or <code>order-history</code>) - load the correct component and then initialize it.</p>
<p>Update <code>src/app.js</code> to:</p>
<pre><code class="language-js">import { DefineMap, route } from 'can';
import RoutePushstate from 'can-route-pushstate';
import debug from 'can-debug#?./is-dev';

//!steal-remove-start
if(debug) {
    debug();
}
//!steal-remove-end

const AppViewModel = DefineMap.extend(&quot;AppViewModel&quot;, {
    page: 'string',
    slug: 'string',
    action: 'string',
  env: {
    default: () =&gt; ({NODE_ENV:'development'})
  },
  title: {
    default: 'place-my-order'
  },
  routeData: {
    default: () =&gt; route.data
  },
  get pageComponent() {
    switch(this.routeData.page) {
      case 'home': {
        return steal.import('~/pages/home.component').then(({default: Home}) =&gt; {
          return new Home();
        });
      }

      case 'restaurants': {
        return steal.import('~/pages/restaurant/list/').then(({default: RestaurantList}) =&gt; {
          return new RestaurantList();
        });
      }

      case 'order-history': {
        return steal.import('~/pages/order/history.component').then(({default: OrderHistory}) =&gt; {
          return new OrderHistory();
        });
      }
    }
  }
});

route.urlData = new RoutePushstate();
route.register(&quot;{page}&quot;, { page: &quot;home&quot; });
route.register('{page}/{slug}', { slug: null });
route.register('{page}/{slug}/{action}', { slug: null, action: null });

export default AppViewModel;

</code></pre>
<div line-highlight='23-44,only'></div>
<p>Update <code>src/index.stache</code> to:</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{{this.title}}&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;minimal-ui, width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;can-import from=&quot;place-my-order-assets&quot; /&gt;
    &lt;can-import from=&quot;~/styles.less&quot; /&gt;
    &lt;can-import from=&quot;~/app&quot; export-as=&quot;viewModel&quot; route-data=&quot;routeData&quot; /&gt;

    &lt;can-import from=&quot;~/components/header.component&quot; /&gt;
    &lt;pmo-header page:from=&quot;this.routeData.page&quot;/&gt;

    {{#if(this.pageComponent.isResolved)}}
      {{this.pageComponent.value}}
    {{else}}
      &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;
    {{/if}}

    {{#eq(this.env.NODE_ENV, &quot;production&quot;)}}
      &lt;script src=&quot;{{joinBase('steal.production.js')}}&quot;&gt;&lt;/script&gt;
    {{else}}
      &lt;script src=&quot;/node_modules/steal/steal.js&quot; main&gt;&lt;/script&gt;
    {{/eq}}
  &lt;/body&gt;
&lt;/html&gt;

</code></pre>
<div line-highlight='11-12,14-18,only'></div>
<p>Here we use a <code>switch</code> statement that checks for the current <code>page</code> property on the <code>route.data</code>, then progressively loads the component with <a href="https://stealjs.com/docs/steal.import.html">steal.import</a> and <a href="https://canjs.com/doc/can-component.html#newComponent__options__">initializes it</a>.</p>
<p>In the template <code>{{#if(this.pageComponent.isResolved)}}</code> shows a loading indicator while the page loads, and then inserts the page (the one instantiated in the Application ViewModel) with <code>{{this.pageComponent.value}}</code>.</p>
<p>Now we can see the header and the home component and be able to navigate to the different pages through the header.</p>
<h2>Getting Data from the Server</h2>
<p>In this next part, we'll connect to the RESTful API that we set up with <code>place-my-order-api</code>, using the powerful data layer provided by <a href="https://canjs.com">CanJS</a> with <a href="https://canjs.com/doc/can-query-logic.html">QueryLogic</a> and <a href="https://canjs.com/doc/can-realtime-rest-model.html">realtimeRestModel</a>.</p>
<h3>Creating a restaurants connection</h3>
<p>At the beginning of this guide we set up a REST API at <a href="http://localhost:7070">http://localhost:7070</a> and told <code>done-serve</code> to proxy it to http://localhost:8080/api.</p>
<p>To manage the restaurant data located at <a href="http://localhost:8080/api/restaurants">http://localhost:8080/api/restaurants</a>, we'll create a restaurant supermodel:</p>
<pre><code class="language-js">donejs add supermodel restaurant
</code></pre>
<p>Answer the question about the URL endpoint with <code>/api/restaurants</code> and the name of the id property with <code>_id</code>.</p>
<p>We have now created a model and fixtures (for testing without an API) with a folder structure like this:</p>
<pre><code class="language-shell">├── node_modules
├── package.json
├── src/
|   ├── app.js
|   ├── index.md
|   ├── index.stache
|   ├── test.js
|   ├── models/
|   |   ├── fixtures/
|   |   |   ├── restaurants.js
|   |   ├── fixtures.js
|   |   ├── restaurant.js
|   |   ├── restaurant-test.js
|   |   ├── test.js
</code></pre>
<h3>Test the connection</h3>
<p>To test the connection you can run the following in the browser console. You can access the browser console by right clicking in the browser and selecting <strong>Inspect</strong>. Then switch to the <strong>Console</strong> tab if not already there. Test the connection with:</p>
<pre><code class="language-js">steal.import(&quot;place-my-order/models/restaurant&quot;)
  .then(function(module) {
    let Restaurant = module[&quot;default&quot;];
    return Restaurant.getList({});
  }).then(function(restaurants) {
    console.log(restaurants);
  });
</code></pre>
<p>This programmatically imports the <code>Restaurant</code> model and uses it to get a list
of all restaurants on the server and log them to the console.</p>
<h3>Add data to the page</h3>
<p>Now, update the <code>ViewModel</code> in <code>src/pages/restaurant/list/list.js</code> to load all restaurants from the restaurant connection:</p>
<pre><code class="language-js">import { Component } from 'can';
import './list.less';
import view from './list.stache';
import Restaurant from '~/models/restaurant';

const RestaurantList = Component.extend({
  tag: 'pmo-restaurant-list',
  view,
  ViewModel: {
    // EXTERNAL STATEFUL PROPERTIES
    // These properties are passed from another component. Example:
    // value: {type: &quot;number&quot;}

    // INTERNAL STATEFUL PROPERTIES
    // These properties are owned by this component.
    restaurants: {
      default() {
        return Restaurant.getList({});
      }
    },

    // DERIVED PROPERTIES
    // These properties combine other property values. Example:
    // get valueAndMessage(){ return this.value + this.message; }

    // METHODS
    // Functions that can be called by the view. Example:
    // incrementValue() { this.value++; }

    // SIDE EFFECTS
    // The following is a good place to perform changes to the DOM
    // or do things that don't fit in to one of the areas above.
    connectedCallback(element){

    }
  }
});

export default RestaurantList;
export const ViewModel = RestaurantList.ViewModel;

</code></pre>
<div line-highlight='4,16-20,only'></div>
<blockquote>
<p><em>Note</em>: we also removed the <strong>message</strong> property.</p>
</blockquote>
<p>And update the template at <code>src/pages/restaurant/list/list.stache</code> to use the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> returned for the <code>restaurants</code> property to render the template:</p>
<pre><code class="language-html">&lt;can-import from=&quot;can-stache-route-helpers&quot; /&gt;

&lt;div class=&quot;restaurants&quot;&gt;
  &lt;h2 class=&quot;page-header&quot;&gt;Restaurants&lt;/h2&gt;
  {{#if(this.restaurants.isPending)}}
    &lt;div class=&quot;restaurant loading&quot;&gt;&lt;/div&gt;
  {{/if}}

  {{#if(this.restaurants.isResolved)}}
    {{#for(restaurant of this.restaurants.value)}}
      {{let addr=restaurant.address}}

      &lt;div class=&quot;restaurant&quot;&gt;
        &lt;img src=&quot;{{joinBase(restaurant.images.thumbnail)}}&quot;
          width=&quot;100&quot; height=&quot;100&quot;&gt;
        &lt;h3&gt;{{restaurant.name}}&lt;/h3&gt;
        
        {{#if(addr)}}
        &lt;div class=&quot;address&quot;&gt;
          {{addr.street}}&lt;br /&gt;{{addr.city}}, {{addr.state}} {{addr.zip}}
        &lt;/div&gt;
        {{/if}}

        &lt;div class=&quot;hours-price&quot;&gt;
          $$$&lt;br /&gt;
          Hours: M-F 10am-11pm
          &lt;span class=&quot;open-now&quot;&gt;Open Now&lt;/span&gt;
        &lt;/div&gt;

        &lt;a class=&quot;btn&quot; href=&quot;{{routeUrl(page='restaurants' slug=restaurant.slug)}}&quot;&gt;
          Details
        &lt;/a&gt;
        &lt;br /&gt;
      &lt;/div&gt;
    {{/for}}
  {{/if}}
&lt;/div&gt;

</code></pre>
<p>By checking for <code>restaurants.isPending</code> and <code>restaurants.isResolved</code> we are able to show a loading indicator while the data are being retrieved. Once resolved, the actual restaurant list is available at <code>restaurants.value</code>. When navigating to the restaurants page now we can see a list of all restaurants.</p>
<p>Note the usage of <code>routeUrl</code> to set up a link that points to each restaurant. <code>slug=slug</code> is not wrapped in quotes because the helper will populate each restaurant's individual <code>slug</code> property in the URL created.</p>
<h2>Creating a unit-tested view model</h2>
<p>In this section we will create a view model for the restaurant list functionality.</p>
<p>We'll show a dropdown of all available US states. When the user selects a state, we'll show a list of cities. Once a city is selected, we'll load a list of all restaurants for that city. The end result will look like this:</p>
<p><img src="static/img/restaurant-list.png" alt="Restaurant list" /></p>
<h3>Identify view model state</h3>
<p>First we need to identify the properties that our view model needs to provide. We want to load a list of states from the server and let the user select a single state. Then we do the same for cities and finally load the restaurant list for that selection.</p>
<p>All asynchronous requests return a Promise, so the data structure will look like this:</p>
<pre><code class="language-js">{
 states: Promise&lt;[State]&gt;
 state: String &quot;IL&quot;,
 cities: Promise&lt;[City]&gt;,
 city: String &quot;Chicago&quot;,
 restaurants: Promise&lt;[Restaurant]&gt;
}
</code></pre>
<h3>Create dependent models</h3>
<p>The API already provides a list of available <a href="http://localhost:8080/api/states">states</a> and <a href="http://localhost:8080/api/cities">cities</a>. To load them we can create the corresponding models like we already did for Restaurants.</p>
<p>Run:</p>
<pre><code class="language-shell">donejs add supermodel state
</code></pre>
<p>When prompted, set the URL to <code>/api/states</code> and the id property to <code>short</code>.</p>
<p>Run:</p>
<pre><code class="language-shell">donejs add supermodel city
</code></pre>
<p>When prompted, set the URL to <code>/api/cities</code> and the id property to <code>name</code>.</p>
<p>Now we can load a list of states and cities.</p>
<h3>Implement view model behavior</h3>
<p>Now that we have identified the view model properties needed and have created the models necessary to load them, we can <a href="https://canjs.com/doc/can-define/map/map.html">define</a> the <code>states</code>, <code>state</code>, <code>cities</code> and <code>city</code> properties in the view model at <code>src/pages/restaurant/list/list.js</code>:</p>
<pre><code class="language-js">import { Component } from 'can';
import './list.less';
import view from './list.stache';
import Restaurant from '~/models/restaurant';
import State from '~/models/state';
import City from '~/models/city';

const RestaurantList = Component.extend({
  tag: 'pmo-restaurant-list',
  view,
  ViewModel: {
    // EXTERNAL STATEFUL PROPERTIES
    // These properties are passed from another component. Example:
    // value: {type: &quot;number&quot;}

    // INTERNAL STATEFUL PROPERTIES
    // These properties are owned by this component.
    get states() {
      return State.getList();
    },
    state: {
      type: 'string',
      default: null
    },
    get cities() {
      let state = this.state;

      if(!state) {
        return null;
      }

      return City.getList({ filter: { state } });
    },
    city: {
      type: 'string',
      value({lastSet, listenTo, resolve}) {
        listenTo(lastSet, resolve);
        listenTo('state', () =&gt; resolve(null));
        resolve(null)
      }
    },
    get restaurants() {
      let state = this.state;
      let city = this.city;

      if(state &amp;&amp; city) {
        return Restaurant.getList({
          filter: {
            'address.state': state,
            'address.city': city
          }
        });
      }

      return null;
    },

    // DERIVED PROPERTIES
    // These properties combine other property values. Example:
    // get valueAndMessage(){ return this.value + this.message; }

    // METHODS
    // Functions that can be called by the view. Example:
    // incrementValue() { this.value++; }

    // SIDE EFFECTS
    // The following is a good place to perform changes to the DOM
    // or do things that don't fit in to one of the areas above.
    connectedCallback(element){

    }
  }
});

export default RestaurantList;
export const ViewModel = RestaurantList.ViewModel;

</code></pre>
<div line-highlight='5-6,18-56,only'></div>
<p>Let's take a closer look at those properties:</p>
<ul>
<li><code>states</code> will return a list of all available states by calling <code>State.getList({})</code></li>
<li><code>state</code> is a string property set to <code>null</code> by default (no selection).</li>
<li><code>cities</code> will return <code>null</code> if no state has been selected. Otherwise, it will load all the cities for a given state by sending <code>state</code> as a query paramater (which will make a request like <a href="http://localhost:8080/api/cities?state=IL">http://localhost:8080/api/cities?state=IL</a>)</li>
<li><code>city</code> is a string, set to <code>null</code> by default. It <a href="https://canjs.com/doc/can-define.types.valueOptions.html">listens to</a> itself being set and resolves to that value. Additionally it listens to <code>state</code> and resolves back to <code>null</code> when it changes.</li>
<li><code>restaurants</code> will always be <code>null</code> unless both a <code>city</code> and a <code>state</code> are selected. If both are selected, it will set the <code>address.state</code> and <code>address.city</code> query parameters which will return a list of all restaurants whose address matches those parameters.</li>
</ul>
<h3>Create a test</h3>
<p>View models that are decoupled from the presentation layer are easy to test. We will use <a href="https://qunitjs.com/">QUnit</a> as the testing framework by loading a StealJS-friendly wrapper (<code>steal-qunit</code>). The component generator created a fully working test page for the component, which can be opened at <a href="http://localhost:8080/src/pages/restaurant/list/test.html">http://localhost:8080/src/pages/restaurant/list/test.html</a>. Currently, the tests will fail because we changed the view model, but in this section we will create some unit tests for the new functionality.</p>
<h4>Fixtures: Create fake data</h4>
<p>Unit tests should be able to run by themselves without the need for an API server. This is where <a href="https://canjs.com/doc/can-fixture.html">fixtures</a> come in. Fixtures allow us to mock requests to the REST API with data that we can use for tests or demo pages. Default fixtures will be provided for every generated model. Now we'll add more realistic fake data by updating <code>src/models/fixtures/states.js</code> to:</p>
<pre><code class="language-js">import { fixture } from 'can';
import State from '../state';

const store = fixture.store([
  { name: 'Calisota', short: 'CA' },
  { name: 'New Troy', short: 'NT'}
], State.connection.queryLogic);

fixture('/api/states/{short}', store);

export default store;

</code></pre>
<div line-highlight='4-7,only'></div>
<p>Update <code>src/models/fixtures/cities.js</code> to look like:</p>
<pre><code class="language-js">import { fixture } from 'can';
import City from '../city';

const store = fixture.store([
  { state: 'CA', name: 'Casadina' },
  { state: 'NT', name: 'Alberny' }
], City.connection.queryLogic);

fixture('/api/cities/{name}', store);

export default store;

</code></pre>
<div line-highlight='4-7,only'></div>
<p>Update <code>src/models/fixtures/restaurants.js</code> to look like:</p>
<pre><code class="language-js">import { fixture } from 'can';
import Restaurant from '../restaurant';

const store = fixture.store([{
  _id: 1,
  name: 'Cheese City',
  slug:'cheese-city',
  address: {
    city: 'Casadina',
    state: 'CA'
  },
  images: {
    banner: &quot;node_modules/place-my-order-assets/images/1-banner.jpg&quot;,
    owner: &quot;node_modules/place-my-order-assets/images/2-owner.jpg&quot;,
    thumbnail: &quot;node_modules/place-my-order-assets/images/3-thumbnail.jpg&quot;
  }
}, {
  _id: 2,
  name: 'Crab Barn',
  slug:'crab-barn',
  address: {
    city: 'Alberny',
    state: 'NT'
  },
  images: {
    banner: &quot;node_modules/place-my-order-assets/images/2-banner.jpg&quot;,
    owner: &quot;node_modules/place-my-order-assets/images/3-owner.jpg&quot;,
    thumbnail: &quot;node_modules/place-my-order-assets/images/2-thumbnail.jpg&quot;
  }
}], Restaurant.connection.queryLogic);

fixture('/api/restaurants/{_id}', store);

export default store;

</code></pre>
<div line-highlight='4-30,only'></div>
<h4>Test the view model</h4>
<p>With fake data in place, we can test our view model by changing <code>src/pages/restaurant/list/list-test.js</code> to:</p>
<pre><code class="language-js">import QUnit from 'steal-qunit';
import cityStore from '~/models/fixtures/cities';
import stateStore from '~/models/fixtures/states';
import restaurantStore from '~/models/fixtures/restaurants';
import { ViewModel } from './list';

QUnit.module('~/restaurant/list', {
  beforeEach() {
    localStorage.clear();
  }
});

QUnit.asyncTest('loads all states', function() {
  var vm = new ViewModel();
  var expectedStates = stateStore.getList({});

  vm.states.then(states =&gt; {
    QUnit.deepEqual(states.serialize(), expectedStates.data, 'Got all states');
    QUnit.start();
  });
});

QUnit.asyncTest('setting a state loads its cities', function() {
  var vm = new ViewModel();
  var expectedCities = cityStore.getList({ filter: { state: &quot;CA&quot; } }).data;

  QUnit.equal(vm.cities, null, '');
  vm.state = 'CA';
  vm.cities.then(cities =&gt; {
    QUnit.deepEqual(cities.serialize(), expectedCities, 'Got all cities');
    QUnit.start();
  });
});

QUnit.asyncTest('changing a state resets city', function() {
  var vm = new ViewModel();
  var expectedCities = cityStore.getList({ filter: { state : &quot;CA&quot; } }).data;

  QUnit.equal(vm.cities, null, '');
  vm.state = 'CA';
  vm.cities.then(cities =&gt; {
    QUnit.deepEqual(cities.serialize(), expectedCities, 'Got all cities');
    vm.state = 'NT';
    QUnit.equal(vm.city, null, 'City reset');
    QUnit.start();
  });
});

QUnit.asyncTest('setting state and city loads a list of its restaurants', function() {
  var vm = new ViewModel();
  vm.bind('city', () =&gt; {});
  var expectedRestaurants = restaurantStore.getList({
    filter: { address: { city: &quot;Alberny&quot; } }
  }).data;

  vm.state = 'NT';
  vm.city = 'Alberny';

  vm.restaurants.then(restaurants =&gt; {
    QUnit.deepEqual(restaurants.serialize(), expectedRestaurants, 'Fetched restaurants equal to expected');
    QUnit.deepEqual(restaurants.length, 1, 'Got expected number of restaurants');
    QUnit.start();
  });
});

</code></pre>
<p>These unit tests are comparing expected data (what we we defined in the fixtures) with actual data (how the view model methods are behaving). Visit <a href="http://localhost:8080/src/pages/restaurant/list/test.html">http://localhost:8080/src/pages/restaurant/list/test.html</a> to see all tests passing.</p>
<h3>Write the template</h3>
<p>Now that our view model is implemented and tested, we'll update the restaurant list template to support the city/state selection functionality.</p>
<p>Update <code>src/pages/restaurant/list/list.stache</code> to:</p>
<pre><code class="language-html">&lt;can-import from=&quot;can-stache-route-helpers&quot; /&gt;

&lt;div class=&quot;restaurants&quot;&gt;
  &lt;h2 class=&quot;page-header&quot;&gt;Restaurants&lt;/h2&gt;
  &lt;form class=&quot;form&quot;&gt;
    &lt;div class=&quot;form-group&quot;&gt;
      &lt;label&gt;State&lt;/label&gt;
      &lt;select value:bind=&quot;this.state&quot; {{#if(this.states.isPending)}}disabled{{/if}}&gt;
        {{#if(this.states.isPending)}}
          &lt;option value=&quot;&quot;&gt;Loading...&lt;/option&gt;
        {{else}}
          {{^if(this.state)}}
          &lt;option value=&quot;&quot;&gt;Choose a state&lt;/option&gt;
          {{/if}}
          {{#for(state of this.states.value)}}
          &lt;option value=&quot;{{state.short}}&quot;&gt;{{state.name}}&lt;/option&gt;
          {{/for}}
        {{/if}}
      &lt;/select&gt;
    &lt;/div&gt;
    &lt;div class=&quot;form-group&quot;&gt;
      &lt;label&gt;City&lt;/label&gt;
      &lt;select value:bind=&quot;this.city&quot;{{^if(this.state)}}disabled{{/if}}&gt;
        {{#if(this.cities.isPending)}}
          &lt;option value=&quot;&quot;&gt;Loading...&lt;/option&gt;
        {{else}}
          {{#if(this.state)}}
            {{^if(this.city)}}
            &lt;option value=&quot;&quot;&gt;Choose a city&lt;/option&gt;
            {{/if}}
            {{#for(city of this.cities.value)}}
            &lt;option value:from=&quot;city.name&quot;&gt;{{city.name}}&lt;/option&gt;
            {{/for}}
          {{/if}}
        {{/if}}
      &lt;/select&gt;
    &lt;/div&gt;
  &lt;/form&gt;

  {{#if(this.restaurants.isPending)}}
    &lt;div class=&quot;restaurant loading&quot;&gt;&lt;/div&gt;
  {{/if}}

  {{#if(this.restaurants.isResolved)}}
    {{console.log(&quot;count&quot;, this.restaurants.value.length)}}
    {{#for(restaurant of this.restaurants.value)}}
      {{let addr=restaurant.address}}

      &lt;div class=&quot;restaurant&quot;&gt;
        &lt;img src=&quot;{{joinBase(restaurant.images.thumbnail)}}&quot;
          width=&quot;100&quot; height=&quot;100&quot;&gt;
        &lt;h3&gt;{{restaurant.name}}&lt;/h3&gt;

        {{#if(addr)}}
        &lt;div class=&quot;address&quot;&gt;
          {{addr.street}}&lt;br /&gt;{{addr.city}}, {{addr.state}} {{addr.zip}}
        &lt;/div&gt;
        {{/if}}

        &lt;div class=&quot;hours-price&quot;&gt;
          $$$&lt;br /&gt;
          Hours: M-F 10am-11pm
          &lt;span class=&quot;open-now&quot;&gt;Open Now&lt;/span&gt;
        &lt;/div&gt;

        &lt;a class=&quot;btn&quot; href=&quot;{{routeUrl(page='restaurants' slug=restaurant.slug)}}&quot;&gt;
          Details
        &lt;/a&gt;
        &lt;br /&gt;
      &lt;/div&gt;
    {{/for}}
  {{/if}}
&lt;/div&gt;

</code></pre>
<div line-highlight='5-38,only'></div>
<p>Some things worth pointing out:</p>
<ul>
<li>Since <code>states</code> and <code>cities</code> return a promise, we can check the promise's status via <code>isResolved</code> and <code>isPending</code> and once resolved get the actual value with <code>states.value</code> and <code>cities.value</code>. This also allows us to easily show loading indicators and disable the select fields while loading data.</li>
<li>The <code>state</code> and <code>city</code> properties are two-way bound to their select fields via <a href="https://canjs.com/doc/can-stache-bindings.twoWay.html#___child_prop____key_">value:bind</a></li>
</ul>
<p>Now we have a component that lets us select state and city and displays the appropriate restaurant list.</p>
<h3>Update the demo page</h3>
<p>We already have an existing demo page at <a href="http://localhost:8080/src/pages/restaurant/list/list.html">src/pages/restaurant/list/list.html</a>. We'll update it to load fixtures so it can demonstrate the use of the pmo-restaurnt-list component:</p>
<pre><code class="language-html">&lt;script src=&quot;../../../../node_modules/steal/steal.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;steal-module&quot;&gt;
  import PmoRestaurantList from &quot;~/pages/restaurant/list/&quot;;
  import &quot;place-my-order-assets&quot;;
  import &quot;~/models/fixtures/&quot;;

  let pmoRestaurantList = new PmoRestaurantList({
    viewModel: {}
  });

  document.body.appendChild(pmoRestaurantList.element);
&lt;/script&gt;

</code></pre>
<div line-highlight='4-5,only'></div>
<p>View the demo page at <a href="http://localhost:8080/src/pages/restaurant/list/list.html">http://localhost:8080/src/pages/restaurant/list/list.html</a> .</p>
<h2>Automated tests</h2>
<p>In this chapter we will automate running the tests so that they can be run from from the command line.</p>
<h3>Using the global test page</h3>
<p>We already worked with an individual component test page in <a href="http://localhost:8080/pages/src/pages/restaurant/list/test.html">src/pages/restaurant/list/test.html</a> but we also have a global test page available at <a href="http://localhost:8080/test.html">test.html</a>. All tests are being loaded in <code>src/test.js</code>. Since we don't have tests for our models at the moment, let's remove the <code>import 'place-my-order/models/test';</code> part so that <code>src/test.js</code> looks like this:</p>
<pre><code class="language-js">import F from 'funcunit';
import QUnit from 'steal-qunit';

import '~/pages/restaurant/list/list-test';

F.attach(QUnit);

QUnit.module('place-my-order functional smoke test', {
  beforeEach() {
    F.open('./development.html');
  }
});

QUnit.test('place-my-order main page shows up', function() {
  F('title').text('place-my-order', 'Title is set');
});

</code></pre>
<p>If you now go to <a href="http://localhost:8080/test.html">http://localhost:8080/test.html</a> we still see all restaurant list tests passing but we will add more here later on.</p>
<h3>Using a test runner</h3>
<p><strong>Note</strong>: If you are using Firefox for development, close the browser temporarily so that we can run our tests.</p>
<p>The tests can be automated with any test runner that supports running QUnit tests. We will use <a href="https://github.com/bitovi/testee">Testee</a> which makes it easy to run those tests in any browser from the command line without much configuration. In fact, everything needed to automatically run the <code>test.html</code> page in Firefox is already set up and we can launch the tests by running:</p>
<pre><code class="language-shell">donejs test
</code></pre>
<p>To see the tests passing on the command line.</p>
<h2>Continuous integration</h2>
<p>Now that the tests can be run from the command line we can automate it in a <a href="https://en.wikipedia.org/wiki/Continuous_integration">continuous integration</a> (CI) environment to run all tests whenever a code change is made. We will use <a href="https://github.com">GitHub</a> to host our code and <a href="https://travis-ci.org/">TravisCI</a> as the CI server.</p>
<h3>Creating a GitHub account and repository</h3>
<p>If you don't have an account yet, go to <a href="https://github.com">GitHub</a> to sign up and follow <a href="https://help.github.com/articles/set-up-git/">the help</a> on how to set it up for use with the command-line <code>git</code>. Once completed, you can create a new repository from your dashboard. Calling the repository <code>place-my-order</code> and initializing it empty (without any of the default files) looks like this:</p>
<p><img src="static/img/guide-create-repo.png" alt="Creating a new repository on GitHub" /></p>
<p>Now we have to initialize Git in our project folder and add the GitHub repository we created as the origin remote (replace <code>&lt;your-username&gt;</code> with your GitHub username):</p>
<pre><code class="language-shell">git init
git remote add origin https://github.com/&lt;your-username&gt;/place-my-order.git
</code></pre>
<p>Then we can add all files and push to origin like this:</p>
<pre><code class="language-shell">git add --all
git commit -am &quot;Initial commit&quot;
git push origin master
</code></pre>
<p>If you now go to <a href="https://github.com/&lt;your-username&gt;/place-my-order">github.com/&lt;your-username&gt;/place-my-order</a> you will see the project files in the repository.</p>
<h3>Setting up Travis CI</h3>
<p>The way our application is set up, now all a continuous integration server has to do is clone the application repository, run <code>npm install</code>, and then run <code>npm test</code>. There are many open source CI servers, the most popular one probably <a href="https://jenkins-ci.org/">Jenkins</a>, and many hosted solutions like <a href="https://travis-ci.org/">Travis CI</a>.</p>
<p>We will use Travis as our hosted solution because it is free for open source projects. It works with your GitHub account which it will use to sign up. First, <a href="https://travis-ci.org/">sign up</a>, then go to <code>Accounts</code> (in the dropdown under you name) to enable the <code>place-my-order</code> repository:</p>
<p><img src="static/img/guide-travis-ci.png" alt="Enabling the repository on Travis CI" /></p>
<p>Continuous integration on GitHub is most useful when using <a href="https://help.github.com/categories/collaborating-on-projects-using-pull-requests/">branches and pull requests</a>. That way your main branch (master) will only get new code changes if all tests pass. Let's create a new branch with</p>
<pre><code class="language-shell">git checkout -b travis-ci
</code></pre>
<p>Run the <a href="https://github.com/donejs/donejs-travis/">donejs-travis</a> generator to add a <code>.travis.yml</code> file to our project root, and to add a <em>Build Passing</em> badge to the top of <code>readme.md</code>:</p>
<pre><code class="language-shell">donejs add travis
</code></pre>
<p>When prompted, confirm the GitHub user name and repository by pressing the Enter key, you can also enter new values if needed:</p>
<pre><code class="language-shell">? What is the GitHub owner name? (&lt;your-username&gt;)
? What is the GitHub repository name? (place-my-order)
</code></pre>
<p>Following these questions, the generator will first update the <a href="https://docs.npmjs.com/files/package.json#repository">package.json's repository</a> field to point it to where your code lives.</p>
<p>Confirm the changes by pressing the Enter key,</p>
<pre><code> conflict package.json
? Overwrite package.json? (Ynaxdh)
</code></pre>
<blockquote>
<p>You can also press the <code>d</code> key to see a diff of the changes before writing to the file.</p>
</blockquote>
<p>Then, the generator creates a <code>.travis.yml</code> file and updates <code>readme.md</code> to include a badge indicating the status of the build, confirm the changes by pressing the Enter key:</p>
<pre><code class="language-shell">conflict README.md
? Overwrite README.md? (Ynaxdh)
</code></pre>
<p>The generated <code>.travis.yml</code> should look like this:</p>
<pre><code class="language-shell">language: node_js
node_js: node
addons:
  firefox: latest
before_install:
  - 'export DISPLAY=:99.0'
  - sh -e /etc/init.d/xvfb start
</code></pre>
<p>By default Travis CI runs <code>npm test</code> for NodeJS projects which is what we want. <code>before_install</code> sets up a window system to run Firefox.</p>
<p>To see Travis run, let's add all changes and push to the branch:</p>
<pre><code class="language-shell">git add --all
git commit -am &quot;Enabling Travis CI&quot;
git push origin travis-ci
</code></pre>
<p>And then create a new pull request by going to <a href="https://github.com/&lt;your-username&gt;/place-my-order">github.com/&lt;your-username&gt;/place-my-order</a> which will now show an option for it:</p>
<p><img src="static/img/guide-github-pr.png" alt="Creating a new pull request on GitHub" /></p>
<p>Once you created the pull request, you will see a <code>Some checks haven’t completed yet</code> message that will eventually turn green like this:</p>
<p><img src="static/img/guide-merge-pr.png" alt="Merging a pull request with all tests passed" /></p>
<p>Once everything turns green, click the &quot;Merge pull request&quot; button.  Then in your console, checkout the <em>master</em> branch and pull down it's latest with:</p>
<pre><code class="language-shell">git checkout master
git pull origin master
</code></pre>
<h2>Nested routes</h2>
<p>In this section, we will add additional pages that are shown under nested urls such as <code>restaurants/cheese-curd-city/order</code>.</p>
<div></div>
<p>Until now we've used three top level routes: <code>home</code>, <code>restaurants</code> and <code>order-history</code>. We did however also define two additional routes in <code>src/app.js</code> which looked like:</p>
<pre><code class="language-js">route.register('{page}/{slug}', { slug: null });
route.register('{page}/{slug}/{action}', { slug: null, action: null });
</code></pre>
<p>We want to use those routes when we are in the <code>restaurants</code> page. The relevant section in <code>pageComponent</code> currently looks like this:</p>
<pre><code class="language-js">case 'restaurants': {
  return steal.import('~/pages/restaurant/list/').then(({default: RestaurantList}) =&gt; {
    return new RestaurantList();
  });
}
</code></pre>
<p>We want to support two additional routes:</p>
<ul>
<li><code>restaurants/{slug}</code>, which shows a details page for the restaurant with <code>slug</code> being a URL friendly short name for the restaurant</li>
<li><code>restaurants/{slug}/order</code>, which shows the menu of the current restaurant and allows us to make a selection and then send our order.</li>
</ul>
<h3>Create additional components</h3>
<p>To make this happen, we need two more components. First, the <code>pmo-restaurant-details</code> component which loads the restaurant (based on the <code>slug</code>) and displays its information.</p>
<pre><code class="language-shell">donejs add component pages/restaurant/details.component pmo-restaurant-details
</code></pre>
<p>And change <code>src/pages/restaurant/details.component</code> to:</p>
<pre><code class="language-html">&lt;can-component tag=&quot;pmo-restaurant-details&quot;&gt;
  &lt;style type=&quot;less&quot;&gt;
    display: block;

    p { font-weight: bold; }
  &lt;/style&gt;
  &lt;view&gt;
    &lt;can-import from=&quot;~/models/restaurant&quot; /&gt;
    &lt;can-import from=&quot;can-stache-route-helpers&quot; /&gt;
    {{#if(this.restaurantPromise.isPending)}}
      &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;
    {{else}}
      {{let restaurant=this.restaurantPromise.value}}
      &lt;div class=&quot;restaurant-header&quot;
          style=&quot;background-image: url({{joinBase(restaurant.images.banner)}});&quot;&gt;
        &lt;div class=&quot;background&quot;&gt;
          &lt;h2&gt;{{restaurant.name}}&lt;/h2&gt;

          {{let addr=restaurant.address}}
          {{#if(addr)}}
          &lt;div class=&quot;address&quot;&gt;
            {{addr.street}}&lt;br /&gt;{{addr.city}}, {{addr.state}} {{addr.zip}}
          &lt;/div&gt;
          {{/if}}

          &lt;div class=&quot;hours-price&quot;&gt;
            $$$&lt;br /&gt;
            Hours: M-F 10am-11pm
            &lt;span class=&quot;open-now&quot;&gt;Open Now&lt;/span&gt;
          &lt;/div&gt;

          &lt;br /&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;restaurant-content&quot;&gt;
        &lt;h3&gt;The best food this side of the Mississippi&lt;/h3&gt;

        &lt;p class=&quot;description&quot;&gt;
          &lt;img src=&quot;{{joinBase(restaurant.images.owner)}}&quot; /&gt;
          Description for {{restaurant.name}}
        &lt;/p&gt;
        &lt;p class=&quot;order-link&quot;&gt;
          &lt;a class=&quot;btn&quot; href=&quot;{{routeUrl(page='restaurants' slug=restaurant.slug action='order')}}&quot;&gt;
            Order from {{restaurant.name}}
          &lt;/a&gt;
        &lt;/p&gt;
      &lt;/div&gt;
    {{/if}}
  &lt;/view&gt;
  &lt;script type=&quot;view-model&quot;&gt;
    import { DefineMap } from 'can';
    import Restaurant from '~/models/restaurant';

    export default DefineMap.extend(&quot;PmoRestaurantDetailsVM&quot;, {
      // EXTERNAL STATEFUL PROPERTIES
      // These properties are passed from another component. Example:
      // value: {type: &quot;number&quot;}

      // INTERNAL STATEFUL PROPERTIES
      // These properties are owned by this component.
      message: { default: &quot;This is the pmo-restaurant-details component&quot; },

      // DERIVED PROPERTIES
      // These properties combine other property values. Example:
      // get valueAndMessage(){ return this.value + this.message; }
      get restaurantPromise() {
        return Restaurant.get({ _id: this.slug });
      },

      // METHODS
      // Functions that can be called by the view. Example:
      // incrementValue() { this.value++; }

      // SIDE EFFECTS
      // The following is a good place to perform changes to the DOM
      // or do things that don't fit in to one of the areas above.
      connectedCallback(element){

      }
    });
  &lt;/script&gt;
&lt;/can-component&gt;

</code></pre>
<p>The order component will be a little more complex, which is why we will put it into its own folder:</p>
<pre><code class="language-shell">donejs add component pages/order/new pmo-order-new
</code></pre>
<p>For now, we will just use placeholder content and implement the functionality in
the following chapters.</p>
<h3>Add to the Application ViewModel routing</h3>
<p>Now we can add those components to the <code>pageComponent</code> property (at <code>src/app.js</code>) with conditions based on the routes that we want to match. Update <code>src/app.js</code> with:</p>
<pre><code class="language-js">import { DefineMap, route, value } from 'can';
import RoutePushstate from 'can-route-pushstate';
import debug from 'can-debug#?./is-dev';

//!steal-remove-start
if(debug) {
    debug();
}
//!steal-remove-end

const AppViewModel = DefineMap.extend(&quot;AppViewModel&quot;, {
  page: 'string',
  slug: 'string',
  action: 'string',
  env: {
    default: () =&gt; ({NODE_ENV:'development'})
  },
  title: {
    default: 'place-my-order'
  },
  routeData: {
    default: () =&gt; route.data
    },
  get pageComponent() {
    switch(this.routeData.page) {
      case 'home': {
        return steal.import('~/pages/home.component').then(({default: Home}) =&gt; {
          return new Home();
        });
      }

      case 'restaurants': {
        if(this.routeData.slug) {
          switch(this.routeData.action) {
            case 'order': {
              return steal.import(&quot;~/pages/order/new/&quot;)
              .then(({default: OrderNew}) =&gt; {
                return new OrderNew({
                  viewModel: {
                    slug: value.from(this.routeData, &quot;slug&quot;)
                  }
                })
              });
            }

            default: {
              return steal.import(&quot;~/pages/restaurant/details.component&quot;)
              .then(({default: RestaurantDetail}) =&gt; {
                return new RestaurantDetail({
                  viewModel: {
                    slug: value.from(this.routeData, &quot;slug&quot;)
                  }
                });
              });
            }
          }
        }

        return steal.import('~/pages/restaurant/list/').then(({default: RestaurantList}) =&gt; {
          return new RestaurantList();
        });
      }

      case 'order-history': {
        return steal.import('~/pages/order/history.component').then(({default: OrderHistory}) =&gt; {
          return new OrderHistory();
        });
      }
    }
  }
});

route.urlData = new RoutePushstate();
route.register(&quot;{page}&quot;, { page: &quot;home&quot; });
route.register('{page}/{slug}', { slug: null });
route.register('{page}/{slug}/{action}', { slug: null, action: null });

export default AppViewModel;

</code></pre>
<div line-highlight='1,33-57,only'></div>
<p>Here we are adding some more conditions if <code>page</code> is set to <code>restaurants</code>:</p>
<ul>
<li>When there is no <code>slug</code> set, show the original restaurant list</li>
<li>When <code>slug</code> is set but no <code>action</code>, show the restaurant details</li>
<li>When <code>slug</code> is set and <code>action</code> is <code>order</code>, show the order component for that restaurant</li>
</ul>
<p>As before, we import the page component based on the state of the route. Since the page component is a class, we can call <code>new</code> to create a new instance. Then we use <a href="https://canjs.com/doc/can-value.from.html">can-value</a> to bind the <code>slug</code> from the route to the component.</p>
<h2>Importing other projects</h2>
<p>The npm integration of StealJS makes it very easy to share and import other components. One thing we want to do when showing the <code>pmo-order-new</code> component is have a tab to choose between the lunch and dinner menu. The good news is that there is already a <a href="https://github.com/bitovi-components/bit-tabs">bit-tabs</a> component which does exactly that. Let's add it as a project dependency with:</p>
<pre><code class="language-shell">npm install bit-tabs@2 --save
</code></pre>
<p>And then integrate it into <code>src/pages/order/new/new.stache</code>:</p>
<pre><code class="language-html">&lt;can-import from=&quot;bit-tabs/unstyled&quot;/&gt;
&lt;div class=&quot;order-form&quot;&gt;
  &lt;h2&gt;Order here&lt;/h2&gt;

  &lt;bit-tabs tabsClass:raw=&quot;nav nav-tabs&quot;&gt;
    &lt;bit-panel title:raw=&quot;Lunch menu&quot;&gt;
      This is the lunch menu
    &lt;/bit-panel&gt;
    &lt;bit-panel title:raw=&quot;Dinner menu&quot;&gt;
      This is the dinner menu
    &lt;/bit-panel&gt;
  &lt;/bit-tabs&gt;
&lt;/div&gt;

</code></pre>
<p>Here we just import the <code>unstyled</code> module from the <code>bit-tabs</code> package using <code>can-import</code> which will then provide the <code>bit-tabs</code> and <code>bit-panel</code> custom elements.</p>
<h2>Creating data</h2>
<p>In this section, we will update the order component to be able to select restaurant menu items and submit a new order for a restaurant.</p>
<h3>Creating the order model</h3>
<p>First, let's look at the restaurant data we get back from the server. It looks like this:</p>
<pre><code class="language-js">{
  &quot;_id&quot;: &quot;5571e03daf2cdb6205000001&quot;,
  &quot;name&quot;: &quot;Cheese Curd City&quot;,
  &quot;slug&quot;: &quot;cheese-curd-city&quot;,
  &quot;images&quot;: {
    &quot;thumbnail&quot;: &quot;images/1-thumbnail.jpg&quot;,
    &quot;owner&quot;: &quot;images/1-owner.jpg&quot;,
    &quot;banner&quot;: &quot;images/2-banner.jpg&quot;
  },
  &quot;menu&quot;: {
    &quot;lunch&quot;: [
      {
        &quot;name&quot;: &quot;Spinach Fennel Watercress Ravioli&quot;,
        &quot;price&quot;: 35.99
      },
      {
        &quot;name&quot;: &quot;Chicken with Tomato Carrot Chutney Sauce&quot;,
        &quot;price&quot;: 45.99
      },
      {
        &quot;name&quot;: &quot;Onion fries&quot;,
        &quot;price&quot;: 15.99
      }
    ],
    &quot;dinner&quot;: [
      {
        &quot;name&quot;: &quot;Gunthorp Chicken&quot;,
        &quot;price&quot;: 21.99
      },
      {
        &quot;name&quot;: &quot;Herring in Lavender Dill Reduction&quot;,
        &quot;price&quot;: 45.99
      },
      {
        &quot;name&quot;: &quot;Roasted Salmon&quot;,
        &quot;price&quot;: 23.99
      }
    ]
  },
  &quot;address&quot;: {
    &quot;street&quot;: &quot;1601-1625 N Campbell Ave&quot;,
    &quot;city&quot;: &quot;Green Bay&quot;,
    &quot;state&quot;: &quot;WI&quot;,
    &quot;zip&quot;: &quot;60045&quot;
  }
}
</code></pre>
<p>We have a <code>menu</code> property which provides a <code>lunch</code> and <code>dinner</code> option (which will show later inside the tabs we set up in the previous chapter). We want to be able to add and remove items from the order, check if an item is in the order already, set a default order status (<code>new</code>), and be able to calculate the order total. For that to happen, we need to create a new <code>item</code> model:</p>
<pre><code class="language-js">import { DefineMap, DefineList} from 'can';

export const Item = DefineMap.extend({
  seal: false
}, {
  price: 'number'
});

export const ItemsList = DefineList.extend({
  '#': Item,
  has: function(item) {
    return this.indexOf(item) !== -1;
  },

  toggle: function(item) {
    var index = this.indexOf(item);

    if (index !== -1) {
      this.splice(index, 1);
    } else {
      this.push(item);
    }
  }
});

</code></pre>
<div line-highlight='1-24,only'></div>
<p>And generate <code>order</code> model:</p>
<pre><code class="language-shell">donejs add supermodel order
</code></pre>
<p>Like the restaurant model, the URL is <code>/api/orders</code> and the id property is <code>_id</code>. To select menu items, we need to add some additional functionality to <code>src/models/order.js</code>:</p>
<pre><code class="language-js">import { DefineMap, DefineList, superModel } from 'can';
import loader from '@loader';
import { ItemsList } from &quot;./item&quot;;

const Order = DefineMap.extend('Order', {
  seal: false
}, {
  '_id': {
    type: 'any',
    identity: true
  },
  name: 'string',
  address: 'string',
  phone: 'string',
  restaurant: 'string',

  status: {
    default: 'new'
  },
  items: {
    Default: ItemsList
  },
  get total() {
    let total = 0.0;
    this.items.forEach(item =&gt;
        total += parseFloat(item.price));
    return total.toFixed(2);
  },
  markAs(status) {
    this.status = status;
    this.save();
  }
});

Order.List = DefineList.extend('OrderList', {
  '#': Order
});

Order.connection = superModel({
  url: loader.serviceBaseURL + '/api/orders',
  Map: Order,
  List: Order.List,
  name: 'order'
});

export default Order;

</code></pre>
<div line-highlight='3,11-32,only'></div>
<p>Add <code>menu</code> property to the <code>restaurant</code> model in <code>src/models/restaurant.js</code>:</p>
<pre><code class="language-js">import { DefineMap, DefineList, superModel } from 'can';
import loader from '@loader';
import { ItemsList } from &quot;./item&quot;;

const Restaurant = DefineMap.extend({
  seal: false
}, {
  '_id': {
    type: 'any',
    identity: true
  },
  menu:{
    type: {
      lunch: {
        Type: ItemsList
      },
      dinner: {
        Type: ItemsList
      }
    }
  }
});

Restaurant.List = DefineList.extend({
  '#': Restaurant
});

Restaurant.connection = superModel({
  url: loader.serviceBaseURL + '/api/restaurants',
  Map: Restaurant,
  List: Restaurant.List,
  name: 'restaurant'
});

export default Restaurant;

</code></pre>
<div line-highlight='3,12-21,only'></div>
<p>Here we define an <code>ItemsList</code> which allows us to toggle menu items and check if they are already in the order. We set up ItemsList as the Value of the items property of an order so we can use its has function and toggle directly in the template. We also set a default value for status and a getter for calculating the order total which adds up all the item prices. We also create another <code>&lt;order-model&gt;</code> tag to load orders in the order history template later.</p>
<h3>Implement the view model</h3>
<p>Now we can update the view model in <code>src/pages/order/new/new.js</code>:</p>
<pre><code class="language-js">import { Component } from 'can';
import './new.less';
import view from './new.stache';
import Restaurant from '~/models/restaurant';
import Order from '~/models/order';

export const PmoOrderNew = Component.extend({
  tag: 'pmo-order-new',
  view,
  ViewModel: {
    // EXTERNAL STATEFUL PROPERTIES
    // These properties are passed from another component. Example:
    // value: {type: &quot;number&quot;}
    slug: 'string',

    // INTERNAL STATEFUL PROPERTIES
    // These properties are owned by this component.
    saveStatus: '*',
    order: {
      Default: Order
    },
    get restaurantPromise() {
      return Restaurant.get({ _id: this.slug });
    },
    restaurant: {
      get(lastSetVal, resolve) {
        this.restaurantPromise.then(resolve);
      }
    },
    get canPlaceOrder() {
      return this.order.items.length;
    },

    // DERIVED PROPERTIES
    // These properties combine other property values. Example:
    // get valueAndMessage(){ return this.value + this.message; }

    // METHODS
    // Functions that can be called by the view. Example:
    // incrementValue() { this.value++; }
    placeOrder(ev) {
      ev.preventDefault();
      let order = this.order;
      order.restaurant = this.restaurant._id;
      this.saveStatus = order.save();
    },
    startNewOrder() {
      this.order = new Order();
      this.saveStatus = null;
    },

    // SIDE EFFECTS
    // The following is a good place to perform changes to the DOM
    // or do things that don't fit in to one of the areas above.
    connectedCallback(element){

    }
  }
});

export default PmoOrderNew;
export const ViewModel = PmoOrderNew.ViewModel;

</code></pre>
<div line-highlight='4-5,14,18-32,41-50,only'></div>
<p>Here we just define the properties that we need: <code>slug</code>, <code>order</code>, <code>canPlaceOrder</code> - which we will use to enable/disable the submit button - and <code>saveStatus</code>, which will become a promise once the order is submitted. <code>placeOrder</code> updates the order with the restaurant information and saves the current order. <code>startNewOrder</code> allows us to submit another order.</p>
<p>While we're here we can also update our test to get it passing again, replace <code>src/pages/order/new/new-test.js</code> with:</p>
<pre><code class="language-js">import QUnit from 'steal-qunit';
import { ViewModel } from './new';

// ViewModel unit tests
QUnit.module('~/pages/order/new');

QUnit.test('canPlaceOrder', function(){
  var vm = new ViewModel({
    order: { items: [1] }
  });
  QUnit.equal(vm.canPlaceOrder, true, 'can place an order');
});

</code></pre>
<div line-highlight='7-12,only'></div>
<h3>Write the template</h3>
<p>First, let's implement a small order confirmation component with</p>
<pre><code class="language-shell">donejs add component components/order/details.component pmo-order-details
</code></pre>
<p>and changing <code>src/components/order/details.component</code> to:</p>
<pre><code class="language-html">&lt;can-component tag=&quot;pmo-order-details&quot;&gt;
  &lt;view&gt;
    {{#if(this.order)}}
      &lt;h3&gt;Thanks for your order {{this.order.name}}!&lt;/h3&gt;
      &lt;div&gt;&lt;label class=&quot;control-label&quot;&gt;
        Confirmation Number: {{this.order._id}}&lt;/label&gt;
      &lt;/div&gt;

      &lt;h4&gt;Items ordered:&lt;/h4&gt;
      &lt;ul class=&quot;list-group panel&quot;&gt;
        {{#for(item of this.order.items)}}
          &lt;li class=&quot;list-group-item&quot;&gt;
            &lt;label&gt;
              {{item.name}} &lt;span class=&quot;badge&quot;&gt;${{item.price}}&lt;/span&gt;
            &lt;/label&gt;
          &lt;/li&gt;
        {{/for}}

        &lt;li class=&quot;list-group-item&quot;&gt;
          &lt;label&gt;
            Total &lt;span class=&quot;badge&quot;&gt;${{this.order.total}}&lt;/span&gt;
          &lt;/label&gt;
        &lt;/li&gt;
      &lt;/ul&gt;

      &lt;div&gt;&lt;label class=&quot;control-label&quot;&gt;
        Phone: {{this.order.phone}}
      &lt;/label&gt;&lt;/div&gt;
      &lt;div&gt;&lt;label class=&quot;control-label&quot;&gt;
        Address: {{this.order.address}}
      &lt;/label&gt;&lt;/div&gt;
    {{/if}}
  &lt;/view&gt;
  &lt;script type=&quot;view-model&quot;&gt;
    import { DefineMap } from 'can';

    export default DefineMap.extend(&quot;PmoOrderDetailsVM&quot;, {
      // EXTERNAL STATEFUL PROPERTIES
      // These properties are passed from another component. Example:
      // value: {type: &quot;number&quot;}
      order: &quot;any&quot;,

      // INTERNAL STATEFUL PROPERTIES
      // These properties are owned by this component.
      message: { default: &quot;This is the pmo-order-details component&quot; },

      // DERIVED PROPERTIES
      // These properties combine other property values. Example:
      // get valueAndMessage(){ return this.value + this.message; }

      // METHODS
      // Functions that can be called by the view. Example:
      // incrementValue() { this.value++; }

      // SIDE EFFECTS
      // The following is a good place to perform changes to the DOM
      // or do things that don't fit in to one of the areas above.
      connectedCallback(element){

      }
    });
  &lt;/script&gt;
&lt;/can-component&gt;

</code></pre>
<p>Now we can import that component and update <code>src/pages/order/new/new.stache</code> to:</p>
<pre><code class="language-html">&lt;can-import from=&quot;bit-tabs/unstyled&quot;/&gt;
&lt;can-import from=&quot;~/components/order/details.component&quot; /&gt;

&lt;div class=&quot;order-form&quot;&gt;
  {{#if(this.restaurantPromise.isPending)}}
    &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;
  {{else}}
    {{#if(this.saveStatus.isResolved)}}
      &lt;pmo-order-details order:from=&quot;this.saveStatus.value&quot;&gt;&lt;/pmo-order-details&gt;
      &lt;p&gt;&lt;a href=&quot;javascript://&quot; on:click=&quot;this.startNewOrder()&quot;&gt;
        Place another order
      &lt;/a&gt;&lt;/p&gt;
    {{else}}
      &lt;h3&gt;Order from {{this.restaurant.name}}&lt;/h3&gt;

      &lt;form on:submit=&quot;this.placeOrder(scope.event)&quot;&gt;
        &lt;bit-tabs tabsClass:raw=&quot;nav nav-tabs&quot;&gt;
          &lt;p class=&quot;info {{^if(this.order.items.length)}}text-error{{else}}text-success{{/if}}&quot;&gt;
            {{^if(this.order.items.length)}}
              Please choose an item
            {{else}}
              {{this.order.items.length}} selected
            {{/if}}
          &lt;/p&gt;
          &lt;bit-panel title:raw=&quot;Lunch menu&quot;&gt;
            &lt;ul class=&quot;list-group&quot;&gt;
              {{#for(item of this.restaurant.menu.lunch)}}
                &lt;li class=&quot;list-group-item&quot;&gt;
                  &lt;label&gt;
                    &lt;input type=&quot;checkbox&quot;
                      on:change=&quot;this.order.items.toggle(item)&quot;
                      {{#if(this.order.items.has(item))}}checked{{/if}}&gt;
                    {{item.name}} &lt;span class=&quot;badge&quot;&gt;${{item.price}}&lt;/span&gt;
                  &lt;/label&gt;
                &lt;/li&gt;
              {{/for}}
            &lt;/ul&gt;
          &lt;/bit-panel&gt;
          &lt;bit-panel title:raw=&quot;Dinner menu&quot;&gt;
            &lt;ul class=&quot;list-group&quot;&gt;
              {{#for(item of restaurant.menu.dinner)}}
                &lt;li class=&quot;list-group-item&quot;&gt;
                  &lt;label&gt;
                    &lt;input type=&quot;checkbox&quot;
                      on:change=&quot;this.order.items.toggle(item)&quot;
                      {{#if(this.order.items.has(item))}}checked{{/if}}&gt;
                    {{item.name}} &lt;span class=&quot;badge&quot;&gt;${{item.price}}&lt;/span&gt;
                  &lt;/label&gt;
                &lt;/li&gt;
              {{/for}}
            &lt;/ul&gt;
          &lt;/bit-panel&gt;
        &lt;/bit-tabs&gt;

        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label class=&quot;control-label&quot;&gt;Name:&lt;/label&gt;
          &lt;input name=&quot;name&quot; type=&quot;text&quot; class=&quot;form-control&quot;
            value:bind=&quot;this.order.name&quot;&gt;
          &lt;p&gt;Please enter your name.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label class=&quot;control-label&quot;&gt;Address:&lt;/label&gt;
          &lt;input name=&quot;address&quot; type=&quot;text&quot; class=&quot;form-control&quot;
            value:bind=&quot;this.order.address&quot;&gt;
          &lt;p class=&quot;help-text&quot;&gt;Please enter your address.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
          &lt;label class=&quot;control-label&quot;&gt;Phone:&lt;/label&gt;
          &lt;input name=&quot;phone&quot; type=&quot;text&quot; class=&quot;form-control&quot;
            value:bind=&quot;this.order.phone&quot;&gt;
          &lt;p class=&quot;help-text&quot;&gt;Please enter your phone number.&lt;/p&gt;
        &lt;/div&gt;
        &lt;div class=&quot;submit&quot;&gt;
          &lt;h4&gt;Total: ${{this.order.total}}&lt;/h4&gt;
          {{#if(this.saveStatus.isPending)}}
            &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;
          {{else}}
            &lt;button type=&quot;submit&quot;
                {{^if(this.canPlaceOrder)}}disabled{{/if}} class=&quot;btn&quot;&gt;
              Place My Order!
            &lt;/button&gt;
          {{/if}}
        &lt;/div&gt;
      &lt;/form&gt;
    {{/if}}
  {{/if}}
&lt;/div&gt;

</code></pre>
<p>This is a longer template so lets walk through it:</p>
<ul>
<li><code>&lt;can-import from=&quot;place-my-order/order/details.component&quot; /&gt;</code> loads the order details component we previously created</li>
<li>If the <code>saveStatus</code> promise is resolved we show the <code>pmo-order-details</code> component with that order</li>
<li>Otherwise we will show the order form with the <code>bit-tabs</code> panels we implemented in the previous chapter and iterate over each menu item</li>
<li><code>on:submit=&quot;this.placeOrder()&quot;</code> will call <code>placeOrder</code> from our view model when the form is submitted</li>
<li>The interesting part for showing a menu item is the checkbox <code>&lt;input type=&quot;checkbox&quot; on:change=&quot;this.order.items.toggle(item)&quot; {{#if this.order.items.has(item)}}checked{{/if}}&gt;</code>
<ul>
<li><code>on:change</code> binds to the checkbox change event and runs <code>this.order.items.toggle</code> which toggles the item from <code>ItemList</code>, which we created in the model</li>
<li><code>this.order.item.has</code> sets the checked status to whether or not this item is in the order</li>
</ul></li>
<li>Then we show form elements for name, address, and phone number, which are bound to the order model using <a href="https://canjs.com/doc/can-stache-bindings.html">can-stache-bindings</a></li>
<li>Finally we disable the button with <code>{{^if(this.canPlaceOrder)}}disabled{{/if}}</code> which gets <code>canPlaceOrder</code> from the view model and returns false if no menu items are selected.</li>
</ul>
<h2>Set up a real-time connection</h2>
<p>can-connect makes it very easy to implement real-time functionality. It is capable of listening to notifications from the server when server data has been created, updated, or removed. This is usually accomplished via <a href="https://en.wikipedia.org/wiki/WebSocket">websockets</a>, which allow sending push notifications to a client.</p>
<h3>Add the Status enum type</h3>
<p>Update <code>src/models/order.js</code> to use <a href="https://canjs.com/doc/can-query-logic.makeEnum.html">QueryLogic.makeEnum</a> so that we can declare all of the possible values for an order's <code>status</code>.</p>
<pre><code class="language-js">import { DefineMap, DefineList, superModel, QueryLogic } from 'can';
import loader from '@loader';

const Status = QueryLogic.makeEnum([&quot;new&quot;, &quot;preparing&quot;, &quot;delivery&quot;, &quot;delivered&quot;]);

const Order = DefineMap.extend('Order', {
  seal: false
}, {
  '_id': {
    type: 'any',
    identity: true
  },
  name: 'string',
  address: 'string',
  phone: 'string',
  restaurant: 'string',

  status: {
    default: 'new',
    Type: Status
  },
  items: {
    Default: ItemsList
  },
  get total() {
    let total = 0.0;
    this.items.forEach(item =&gt;
        total += parseFloat(item.price));
    return total.toFixed(2);
  },
  markAs(status) {
    this.status = status;
    this.save();
  }
});

Order.List = DefineList.extend('OrderList', {
  '#': Order
});

Order.connection = superModel({
  url: loader.serviceBaseURL + '/api/orders',
  Map: Order,
  List: Order.List,
  name: 'order'
});

export default Order;

</code></pre>
<div line-highlight='1,4,19-20,only'></div>
<h3>Update the template</h3>
<p>First let's create the <code>pmo-order-list</code> component with:</p>
<pre><code class="language-shell">donejs add component components/order/list.component pmo-order-list
</code></pre>
<p>And then change <code>src/components/order/list.component</code> to:</p>
<pre><code class="language-html">&lt;can-component tag=&quot;pmo-order-list&quot;&gt;
  &lt;view&gt;
    &lt;h4&gt;{{this.listTitle}}&lt;/h4&gt;

    {{#if(this.orders.isPending)}}
     &lt;div class=&quot;loading&quot;&gt;&lt;/div&gt;
    {{else}}
      {{#for(order of this.orders.value)}}
      &lt;div class=&quot;order {{order.status}}&quot;&gt;
        &lt;address&gt;
          {{order.name}} &lt;br /&gt;{{order.address}} &lt;br /&gt;{{order.phone}}
        &lt;/address&gt;

        &lt;div class=&quot;items&quot;&gt;
          &lt;ul&gt;
            {{#for(item of order.items)}}&lt;li&gt;{{item.name}}&lt;/li&gt;{{/for}}
          &lt;/ul&gt;
        &lt;/div&gt;

        &lt;div class=&quot;total&quot;&gt;${{order.total}}&lt;/div&gt;

        &lt;div class=&quot;actions&quot;&gt;
          &lt;span class=&quot;badge&quot;&gt;{{this.statusTitle}}&lt;/span&gt;
          {{#if(this.action)}}
            &lt;p class=&quot;action&quot;&gt;
              Mark as:
              &lt;a href=&quot;javascript://&quot; on:click=&quot;order.markAs(this.action)&quot;&gt;
                {{this.actionTitle}}
              &lt;/a&gt;
            &lt;/p&gt;
          {{/if}}

          &lt;p class=&quot;action&quot;&gt;
            &lt;a href=&quot;javascript://&quot;  on:click=&quot;order.destroy()&quot;&gt;Delete&lt;/a&gt;
          &lt;/p&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      {{else}}
        &lt;div class=&quot;order empty&quot;&gt;{{this.emptyMessage}}&lt;/div&gt;
      {{/for}}
    {{/if}}
  &lt;/view&gt;
  &lt;script type=&quot;view-model&quot;&gt;
    import { DefineMap } from 'can';

    export default DefineMap.extend(&quot;PmoOrderListVM&quot;, {
      // EXTERNAL STATEFUL PROPERTIES
      // These properties are passed from another component. Example:
      // value: {type: &quot;number&quot;}
      orders: &quot;any&quot;,
      listTitle: &quot;string&quot;,
      status: &quot;string&quot;,
      statusTitle: &quot;string&quot;,
      action: &quot;string&quot;,
      actionTitle: &quot;string&quot;,
      emptyMessage: &quot;string&quot;,

      // INTERNAL STATEFUL PROPERTIES
      // These properties are owned by this component.

      // DERIVED PROPERTIES
      // These properties combine other property values. Example:
      // get valueAndMessage(){ return this.value + this.message; }

      // METHODS
      // Functions that can be called by the view. Example:
      // incrementValue() { this.value++; }

      // SIDE EFFECTS
      // The following is a good place to perform changes to the DOM
      // or do things that don't fit in to one of the areas above.
      connectedCallback(element){

      }
    });
  &lt;/script&gt;
&lt;/can-component&gt;

</code></pre>
<p>Also update the order history template by changing <code>src/pages/order/history.component</code> to:</p>
<pre><code class="language-html">&lt;can-component tag=&quot;pmo-order-history&quot;&gt;
  &lt;view&gt;
    &lt;can-import from=&quot;~/components/order/list.component&quot; /&gt;
    &lt;div class=&quot;order-history&quot;&gt;
      &lt;div class=&quot;order header&quot;&gt;
        &lt;address&gt;Name / Address / Phone&lt;/address&gt;
        &lt;div class=&quot;items&quot;&gt;Order&lt;/div&gt;
        &lt;div class=&quot;total&quot;&gt;Total&lt;/div&gt;
        &lt;div class=&quot;actions&quot;&gt;Action&lt;/div&gt;
      &lt;/div&gt;

      &lt;pmo-order-list
        orders:from=&quot;this.statusNew&quot;
        listTitle:raw=&quot;New Orders&quot;
        status:raw=&quot;new&quot;
        statusTitle:raw=&quot;New Order!&quot;
        action:raw=&quot;preparing&quot;
        actionTitle:raw=&quot;Preparing&quot;
        emptyMessage:raw=&quot;No new orders&quot;/&gt;

      &lt;pmo-order-list
        orders:from=&quot;this.statusPreparing&quot;
        listTitle:raw=&quot;Preparing&quot;
        status:raw=&quot;preparing&quot;
        statusTitle:raw=&quot;Preparing&quot;
        action:raw=&quot;delivery&quot;
        actionTitle:raw=&quot;Out for delivery&quot;
        emptyMessage:raw=&quot;No orders preparing&quot;/&gt;

      &lt;pmo-order-list
        orders:from=&quot;this.statusDelivery&quot;
        listTitle:raw=&quot;Out for delivery&quot;
        status:raw=&quot;delivery&quot;
        statusTitle:raw=&quot;Out for delivery&quot;
        action:raw=&quot;delivered&quot;
        actionTitle:raw=&quot;Delivered&quot;
        emptyMessage:raw=&quot;No orders are being delivered&quot;/&gt;

      &lt;pmo-order-list
        orders:from=&quot;this.statusDelivered&quot;
        listTitle:raw=&quot;Delivered&quot;
        status:raw=&quot;delivered&quot;
        statusTitle:raw=&quot;Delivered&quot;
        emptyMessage:raw=&quot;No delivered orders&quot;/&gt;
    &lt;/div&gt;
  &lt;/view&gt;
  &lt;script type=&quot;view-model&quot;&gt;
    import { DefineMap } from 'can';
    import Order from '~/models/order';

    export default DefineMap.extend(&quot;PmoOrderHistoryVM&quot;, {
      // EXTERNAL STATEFUL PROPERTIES
      // These properties are passed from another component. Example:
      // value: {type: &quot;number&quot;}

      // INTERNAL STATEFUL PROPERTIES
      // These properties are owned by this component.
      message: { default: &quot;This is the pmo-order-history component&quot; },

      // DERIVED PROPERTIES
      // These properties combine other property values. Example:
      // get valueAndMessage(){ return this.value + this.message; }
      get statusNew() {
        return Order.getList({ filter: { status: &quot;new&quot; }});
      },
      get statusPreparing() {
        return Order.getList({ filter: { status: &quot;preparing&quot; }});
      },
      get statusDelivery() {
        return Order.getList({ filter: { status: &quot;delivery&quot; }});
      },
      get statusDelivered() {
        return Order.getList({ filter: { status: &quot;delivered&quot; }});
      },

      // METHODS
      // Functions that can be called by the view. Example:
      // incrementValue() { this.value++; }

      // SIDE EFFECTS
      // The following is a good place to perform changes to the DOM
      // or do things that don't fit in to one of the areas above.
      connectedCallback(element){

      }
    });
  &lt;/script&gt;
&lt;/can-component&gt;

</code></pre>
<p>First we import the order model and then just call <code>&lt;order-model get-list=&quot;{status='&lt;status&gt;'}&quot;&gt;</code> for each order status. These are all of the template changes needed, next is to set up the real-time connection.</p>
<h3>Adding real-time events to a model</h3>
<p>The <code>place-my-order-api</code> module uses the <a href="https://feathersjs.com/">Feathers</a> NodeJS framework, which in addition to providing a REST API, sends those events in the form of a websocket event like <code>orders created</code>. To make the order page update in real-time, all we need to do is add listeners for those events to <code>src/models/order.js</code> and in the handler notify the order connection.</p>
<pre><code class="language-shell">npm install steal-socket.io@4 --save
</code></pre>
<p>Update <code>src/models/order.js</code> to use socket.io to update the Order model in real-time:</p>
<pre><code class="language-js">import { DefineMap, DefineList, superModel, QueryLogic } from 'can';
import loader from '@loader';
import io from 'steal-socket.io';

const Status = QueryLogic.makeEnum([&quot;new&quot;, &quot;preparing&quot;, &quot;delivery&quot;, &quot;delivered&quot;]);

const Order = DefineMap.extend('Order', {
  seal: false
}, {
  '_id': {
    type: 'any',
    identity: true
  },
  name: 'string',
  address: 'string',
  phone: 'string',
  restaurant: 'string',

  status: {
    default: 'new',
    Type: Status
  },
  items: {
    Default: ItemsList
  },
  get total() {
    let total = 0.0;
    this.items.forEach(item =&gt;
        total += parseFloat(item.price));
    return total.toFixed(2);
  },
  markAs(status) {
    this.status = status;
    this.save();
  }
});

Order.List = DefineList.extend('OrderList', {
  '#': Order
});

Order.connection = superModel({
  url: loader.serviceBaseURL + '/api/orders',
  Map: Order,
  List: Order.List,
  name: 'order'
});

const socket = io(loader.serviceBaseURL);

socket.on('orders created', order =&gt; Order.connection.createInstance(order));
socket.on('orders updated', order =&gt; Order.connection.updateInstance(order));
socket.on('orders removed', order =&gt; Order.connection.destroyInstance(order));

export default Order;

</code></pre>
<div line-highlight='3,49-53,only'></div>
<p>That's it. If we now open the <a href="http://localhost:8080/order-history">order page</a> we see some already completed default orders. Keeping the page open and placing a new order from another browser or device will update our order page automatically.</p>
<h2>Create documentation</h2>
<p>Documenting our code is very important to quickly get other developers up to speed. <a href="https://documentjs.com/">DocumentJS</a> makes documenting code easier. It will generate a full documentation page from Markdown files and code comments in our project.</p>
<h3>Installing and Configuring DocumentJS</h3>
<p>Let's add DocumentJS to our application:</p>
<pre><code class="language-shell">donejs add documentjs@0.1
</code></pre>
<p>This will install DocumentJS and also create a <code>documentjs.json</code> configuration file. Now we can generate the documentation with:</p>
<pre><code class="language-shell">donejs document
</code></pre>
<p>This produces documentation at <a href="http://localhost:8080/docs/">http://localhost:8080/docs/</a>.</p>
<h3>Documenting a module</h3>
<p>Let's add the documentation for a module. Let's use <code>src/pages/order/new/new.js</code> and update it with some inline comments that describe what our view model properties are supposed to do:</p>
<pre><code class="language-js">import { Component } from 'can';
import './new.less';
import view from './new.stache';
import Restaurant from '~/models/restaurant';
import Order from '~/models/order';

export const PmoOrderNew = Component.extend({
  tag: 'pmo-order-new',
  view,

  /**
   * @add ~/pages/order/new
   */
  ViewModel: {
    // EXTERNAL STATEFUL PROPERTIES
    // These properties are passed from another component. Example:
    // value: {type: &quot;number&quot;}

    /**
     * @property {string} slug
     *
     * the restaurants slug (short name). will
     * be used to request the actual restaurant.
     */
    slug: 'string',

    // INTERNAL STATEFUL PROPERTIES
    // These properties are owned by this component.

    /**
      * @property {Promise} saveStatus
      *
      * a Promise that contains the status of the order when
      * it is being saved.
      */
    saveStatus: '*',
    /**
     * @property {~/models/order} order
     *
     * the order that is being processed. will
     * be an empty new order inititally.
     */
    order: {
      Default: Order
    },
    /**
      * @property {Promise} restaurantPromise
      *
      * a Promise that contains the restaurant that is being
      * ordered from.
      */
    get restaurantPromise() {
      return Restaurant.get({ _id: this.slug });
    },
    /**
     * @property {~/models/restaurant} restaurant
     *
     * the restaurant that is being ordered from.
     */
    restaurant: {
      get(lastSetVal, resolve) {
        this.restaurantPromise.then(resolve);
      }
    },
    /**
      * @property {Boolean} canPlaceOrder
      *
      * boolean indicating whether the order
      * can be placed.
      */
    get canPlaceOrder() {
      return this.order.items.length;
    },

    // DERIVED PROPERTIES
    // These properties combine other property values. Example:
    // get valueAndMessage(){ return this.value + this.message; }

    // METHODS
    // Functions that can be called by the view. Example:
    // incrementValue() { this.value++; }

    /**
     * @function placeOrder
     *
     * save the current order and update the status deferred.
     */
    placeOrder(ev) {
      ev.preventDefault();
      let order = this.order;
      order.restaurant = this.restaurant._id;
      this.saveStatus = order.save();
    },
    /**
     * @function startNewOrder
     *
     * resets the order form, so a new order can be placed.
     */
    startNewOrder() {
      this.order = new Order();
      this.saveStatus = null;
    },

    // SIDE EFFECTS
    // The following is a good place to perform changes to the DOM
    // or do things that don't fit in to one of the areas above.
    connectedCallback(element){

    }
  }
});

export default PmoOrderNew;
export const ViewModel = PmoOrderNew.ViewModel;

</code></pre>
<div line-highlight='11-13,19-24,30-35,37-42,46-51,55-59,65-70,83-87,94-98,only'></div>
<p>If we now run <code>donejs document</code> again, we will see the module show up in the menu bar and will be able to navigate through the different properties.</p>
<h2>Production builds</h2>
<p>Now we're ready to create a production build; go ahead and kill your development server, we won't need it from here on.</p>
<h3>Progressive loading</h3>
<p>Our <code>app.js</code> contains steal.import() calls for each of the pages we have implemented. These dynamic imports progressively load page components only when the user visits that page.</p>
<h3>Bundling assets</h3>
<p>Likely you have assets in your project other than your JavaScript and CSS that you will need to deploy to production. Place My Order has these assets saved to another project, you can view them at <code>node_modules/place-my-order-assets/images</code>.</p>
<p>StealTools comes with the ability to bundle all of your static assets into a folder that can be deployed to production by itself. Think if it as a zip file that contains everything your app needs to run in production.</p>
<p>To use this capability add an option to your build script to enable it. Change:</p>
<pre><code class="language-js">let buildPromise = stealTools.build({
  config: __dirname + &quot;/package.json!npm&quot;
}, {
  bundleAssets: true
});
</code></pre>
<p>to:</p>
<pre><code class="language-js">let buildPromise = stealTools.build({
  config: __dirname + &quot;/package.json!npm&quot;
}, {
  bundleAssets: {
    infer: false,
    glob: &quot;node_modules/place-my-order-assets/images/**/*&quot;
  }
});
</code></pre>
<div line-highlight='4-7,only'></div>
<p>StealTools will find all of the assets you reference in your CSS and copy them to the dist folder. By default StealTools will set your <a href="https://stealjs.com/docs/steal-tools.build.html#dest">dest</a> to <code>dist</code>, and will place the place-my-order-assets images in <code>dist/node_modules/place-my-order/assets/images</code>. bundleAssets preserves the path of your assets so that their locations are the same relative to the base url in both development and production.</p>
<h3>Bundling your app</h3>
<p>To bundle our application for production we use the build script in <code>build.js</code>. We could also use <a href="http://gruntjs.com/">Grunt</a> or <a href="http://gulpjs.com/">Gulp</a>, but in this example we just run it directly with Node. Everything is set up already so we run:</p>
<pre><code class="language-shell">donejs build
</code></pre>
<p>This will build the application to a <code>dist/</code> folder in the project's base directory.</p>
<p>From here your application is ready to be used in production. Enable production mode by setting the <code>NODE_ENV</code> variable:</p>
<pre><code class="language-shell">NODE_ENV=production donejs start
</code></pre>
<p>If you're using Windows omit the NODE_ENV=production in the command, and instead see the <a href="./SettingUp.html#environmental-variables">setting up guide</a> on how to set environment variables.</p>
<p>Refresh your browser to see the application load in production.</p>
<h2>Desktop and mobile apps</h2>
<h3>Building to iOS and Android</h3>
<p>To build the application as a Cordova based mobile application, you need to have each platform's SDK installed.
We'll be building an iOS app if you are a Mac user, and an Android app if you're a Windows user.</p>
<p>Mac users should download XCode from the AppStore and install the <code>ios-sim</code> package globally with:</p>
<pre><code class="language-shell">npm install -g ios-sim
</code></pre>
<p>We will use these tools to create an iOS application that can be tested in the iOS simulator.</p>
<p>Windows users should install the <a href="https://developer.android.com/sdk/index.html">Android Studio</a>, which gives all of the tools we need. See the <a href="./SettingUp.html#android-development-1">setting up guide</a> for full instructions on setting up your Android emulator.</p>
<p>Now we can install the DoneJS Cordova tools with:</p>
<pre><code class="language-shell">donejs add cordova@2
</code></pre>
<p>Answer the question about the URL of the service layer with <code>http://www.place-my-order.com</code>.</p>
<p>Depending on your operating system you can accept most of the rest of the defaults, unless you would like to build for Android, which needs to be selected from the list of platforms.</p>
<p>This will change your <code>build.js</code> script with the options needed to build iOS/Android apps. Open this file and add the place-my-order-asset images to the <strong>glob</strong> property:</p>
<pre><code class="language-js">let cordovaOptions = {
  buildDir: &quot;./build/cordova&quot;,
  id: &quot;com.donejs.placemyorder&quot;,
  name: &quot;place my order&quot;,
  platforms: [&quot;ios&quot;],
  plugins: [&quot;cordova-plugin-transport-security&quot;],
  index: __dirname + &quot;/production.html&quot;,
  glob: [
    &quot;node_modules/place-my-order-assets/images/**/*&quot;
  ]
};
</code></pre>
<div line-highlight='9,only'></div>
<p>To run the Cordova build and launch the simulator we can now run:</p>
<pre><code class="language-shell">donejs build cordova
</code></pre>
<p>If everything went well, we should see the emulator running our application.</p>
<h3>Building to Electron</h3>
<p>To set up the desktop build, we have to add it to our application like this:</p>
<pre><code class="language-shell">donejs add electron@2
</code></pre>
<p>Answer the question about the URL of the service layer with <code>http://www.place-my-order.com</code>. We can answer the rest of the prompts with the default.</p>
<p>Then we can run the build like this:</p>
<pre><code class="language-shell">donejs build electron
</code></pre>
<p>The macOS application can be opened with</p>
<pre><code class="language-shell">open build/place-my-order-darwin-x64/place-my-order.app
</code></pre>
<p>The Windows application can be opened with</p>
<pre><code class="language-shell">.\build\place-my-order-win32-x64\place-my-order.exe
</code></pre>
<h2>Deploy</h2>
<p>Now that we verified that our application works in production, we can deploy it to the web. In this section, we will use <a href="https://www.firebase.com/">Firebase</a>, a service that provides static file hosting and <a href="https://en.wikipedia.org/wiki/Content_delivery_network">Content Delivery Network</a> (CDN) support, to automatically deploy and serve our application's static assets from a CDN and <a href="https://heroku.com">Heroku</a> to provide server-side rendering.</p>
<h3>Static hosting on Firebase</h3>
<p>Sign up for free at <a href="https://firebase.google.com/">Firebase</a>. After you have an account go to <a href="https://console.firebase.google.com/">Firebase console</a> and create an app called <code>place-my-order-&lt;user&gt;</code> where <code>&lt;user&gt;</code> is your GitHub username:</p>
<p><img src="static/img/guide-firebase-setup.png" alt="two browsers" style="box-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2); border-radius: 5px; border: 1px #E7E7E7 solid; max-width: 400px;" /></p>
<p>Write down the name of your app's ID because you'll need it in the next section.</p>
<blockquote>
<p>You will get an error if your app name is too long, so pick something on the shorter side, for example <code>pmo-&lt;user&gt;</code>.</p>
</blockquote>
<p>When you deploy for the first time it will ask you to authorize with your login information, but first we need to configure the project.</p>
<h4>Configuring DoneJS</h4>
<p>With the Firebase account and application in place we can add the deployment configuration to our project like this:</p>
<pre><code class="language-shell">donejs add firebase@1
</code></pre>
<p>When prompted, enter the name of the application created when you set up the Firebase app. Next, login to the firebase app for the first time by running:</p>
<pre><code class="language-shell">node_modules/.bin/firebase login
</code></pre>
<p>And authorize your application.</p>
<h4>Run deploy</h4>
<p>We can now deploy the application by running:</p>
<pre><code class="language-shell">donejs build
donejs deploy
</code></pre>
<p>Static files are deployed to Firebase and we can verify that the application is loading from the CDN by loading it running:</p>
<pre><code class="language-shell">NODE_ENV=production donejs start
</code></pre>
<blockquote>
<p>If you're using Windows, set the NODE_ENV variable as you did previously in the Production section.</p>
</blockquote>
<p>We should now see our assets being loaded from the Firebase CDN like this:</p>
<p><img src="static/img/guide-firebase-network.png" alt="A network tab when using the CDN" /></p>
<h3>Deploy your Node code</h3>
<p>At this point your application has been deployed to a CDN. This contains StealJS, your production bundles and CSS, and any images or other static files. You still need to deploy your server code in order to get the benefit of server-side rendering.</p>
<p>If you do not have an account yet, sign up for Heroku at <a href="https://signup.heroku.com/">signup.heroku.com</a>. Then download the <a href="https://devcenter.heroku.com/articles/heroku-command">Heroku CLI</a> which will be used to deploy.</p>
<p>After installing run the <a href="https://github.com/donejs/donejs-heroku">donejs-heroku</a> generator via:</p>
<pre><code class="language-shell">donejs add heroku
</code></pre>
<p>Once you have logged in into your Heroku account, choose whether you want Heroku to use a random
name for the application. If you choose not to use a random name, you will be prompted to enter
the application name:</p>
<blockquote>
<p>We recommend you to use a random name since Heroku fails to create the app if the name is already taken.</p>
</blockquote>
<pre><code class="language-shell">? Do you want Heroku to use a random app name? Yes
</code></pre>
<p>When prompted, press the <code>Y</code> key since the application requires a proxy</p>
<pre><code class="language-shell">? Does the application require a Proxy? Yes
</code></pre>
<p>Then enter <code>http://www.place-my-order.com/api</code> as the proxy url:</p>
<pre><code class="language-shell">? What's the Proxy url? http://www.place-my-order.com/api
</code></pre>
<p>Once the generator finishes, update the NODE_ENV variable via:</p>
<pre><code class="language-shell">heroku config:set NODE_ENV=production
</code></pre>
<p>and follow the generator instructions to save our current changes:</p>
<pre><code class="language-shell">git add --all
git commit -m &quot;Finishing place-my-order&quot;
git push origin master
</code></pre>
<p>Since Heroku needs the build artifacts we need to commit those before pushing to Heroku. We recommend doing this in a separate branch.</p>
<pre><code class="language-shell">git checkout -b deploy
git add -f dist
git commit -m &quot;Deploying to Heroku&quot;
</code></pre>
<p>And finally do an initial deploy.</p>
<pre><code class="language-shell">git push heroku deploy:master
</code></pre>
<p>Any time in the future you want to deploy simply push to the Heroku remote. Once the deploy is finished you can open the link provided in your browser. If successful we can checkout the <em>master</em> branch:</p>
<pre><code class="language-shell">git checkout master
</code></pre>
<h3>Continuous Deployment</h3>
<p>Previously we set up Travis CI <a href="#continuous-integration">for automated testing</a> of our application code as we developed, but Travis (and other CI solutions) can also be used to deploy our code to production once tests have passed.</p>
<p>In order to deploy to Heroku you need to provide Travis with your Heroku API key. Sensitive information in our <code>.travis.yml</code> should always be encrypted, and the generator takes care of encrypting the API key using the <a href="https://www.npmjs.com/package/travis-encrypt">travis-encrypt</a> module.</p>
<p><em>Note: if using Windows, first install the OpenSSL package as described in the <a href="https://donejs.com/SettingUp.html">Setting Up</a> guide.</em></p>
<p>Run the <a href="https://github.com/donejs/donejs-travis-deploy-to-heroku">donejs-travis-deploy-to-heroku</a> generator like this:</p>
<pre><code class="language-shell">donejs add travis-deploy-to-heroku
</code></pre>
<p>When prompted, confirm each prompt by pressing the Enter key (or enter new values if needed) and then confirm the changes made to the <code>.travis.yml</code> file.</p>
<p>The updated <code>.travis.yml</code> should look like this:</p>
<pre><code class="language-yaml">language: node_js
node_js: node
addons:
  firefox: latest
before_install:
  - 'export DISPLAY=:99.0'
  - sh -e /etc/init.d/xvfb start
deploy:
  skip_cleanup: true
  provider: heroku
  app: &lt;heroku-appname&gt;
  api_key: &lt;encrypted-heroku-api-key&gt;
before_deploy:
  - git config --global user.email &quot;me@example.com&quot;
  - git config --global user.name &quot;deploy bot&quot;
  - node build
  - git add dist/ --force
  - git commit -m &quot;Updating build.&quot;
</code></pre>
<div line-highlight='8-18,only'></div>
<blockquote>
<p>The <code>donejs-travis-deploy-to-heroku</code> generator retrieves data from local configuration files, if any of the values set as default is incorrect, you can enter the correct value when prompted. To find the name of the Heroku application run <code>heroku apps:info</code>; or run <code>heroku auth:token</code> if you want to see your authentication token.</p>
</blockquote>
<p>Next, we set up Travis CI to deploy to <a href="https://www.firebase.com/">Firebase</a> as well. To automate the deploy to Firebase you need to provide the Firebase CI token. You can get the token by running:</p>
<pre><code class="language-shell">node_modules/.bin/firebase login:ci
</code></pre>
<p>In the application folder. It will open a browser window and ask you to authorize the application. Once successful, copy the token and enter it when prompted by the <a href="https://github.com/donejs/donejs-travis-deploy-to-firebase">travis-deploy-to-firebase</a> generator.</p>
<p>Run the following command:</p>
<pre><code class="language-shell">donejs add travis-deploy-to-firebase
</code></pre>
<p>Confirm your GitHub username and application name, then enter the Firebase CI Token from the previous step:</p>
<pre><code class="language-shell">? What's your GitHub username? &lt;your-username&gt;
? What's your GitHub application name? place-my-order
? What's your Firebase CI Token? &lt;your-firebase-ci-token&gt;
</code></pre>
<p>And press the Enter key to update the <code>.travis.yml</code> file which should now look like this:</p>
<pre><code class="language-yaml">language: node_js
node_js: node
addons:
  firefox: latest
before_install:
  - 'export DISPLAY=:99.0'
  - sh -e /etc/init.d/xvfb start
deploy:
  skip_cleanup: true
  provider: heroku
  app: &lt;heroku-appname&gt;
  api_key: &lt;encrypted-heroku-api-key&gt;
before_deploy:
  - git config --global user.email &quot;me@example.com&quot;
  - git config --global user.name &quot;deploy bot&quot;
  - node build
  - git add dist/ --force
  - git commit -m &quot;Updating build.&quot;
  - 'npm run deploy:ci'
env:
  global:
    - secure: &lt;encrypted-firebase-ci-token&gt;
</code></pre>
<div line-highlight='19-22,only'></div>
<p>Now any time a build succeeds when pushing to <code>master</code> the application will be deployed to Heroku and static assets to Firebase's CDN.</p>
<p>To test this out checkout a new branch:</p>
<pre><code class="language-shell">git checkout -b continuous
git add -A
git commit -m &quot;Trying out continuous deployment&quot;
git push origin continuous
</code></pre>
<p>Visit your GitHub page, create a pull-request, wait for tests to pass and then merge. Visit your Travis CI build page at <a href="https://travis-ci.org/&lt;your-username&gt;/place-my-order">https://travis-ci.org/&lt;your-username&gt;/place-my-order</a> to see the deployment happening in real time like this:</p>
<p><img src="static/img/guide-travis-deploy.png" alt="The Travis CI deploy" /></p>
<h2>What's next?</h2>
<p>In this final short chapter, let's quickly look at what we did in this guide and where to follow up for any questions.</p>
<h3>Recap</h3>
<p>In this in-depth guide we created and deployed a fully tested restaurant menu ordering application called <a href="http://www.place-my-order.com/">place-my-order</a> with DoneJS. We learned how to set up a DoneJS project, create custom elements and retrieve data from the server. Then we implemented a unit-tested view-model, ran those tests automatically from the command line and on a continuous integration server.</p>
<p>We went into more detail on how to create nested routes and importing other projects from npm. Then we created new orders and made it real-time, added and built documentation and made a production build. Finally we turned that same application into a desktop and mobile application and deployed it to a CDN and the web.</p>
<h3>Following up</h3>
<p>You can learn more about each of the individual projects that DoneJS includes at:</p>
<ul>
<li><a href="https://stealjs.com">StealJS</a> - ES6, CJS, and AMD module loader and builder</li>
<li><a href="https://canjs.com">CanJS</a> - Custom elements and Model-View-ViewModel utilities</li>
<li><a href="https://jquery.com">jQuery</a> - DOM helpers</li>
<li><a href="https://jquerypp.com">jQuery++</a> - Extended DOM helpers</li>
<li><a href="https://qunitjs.com/">QUnit</a> or Mocha - Assertion library</li>
<li><a href="https://funcunit.com">FuncUnit</a> - Functional tests</li>
<li><a href="https://github.com/bitovi/testee">Testee</a> - Test runner</li>
<li><a href="https://documentjs.com">DocumentJS</a> - Documentation</li>
</ul>
<p>If you have any questions, do not hesitate to ask us on <a href="https://www.bitovi.com/community/slack">Slack</a> (<a href="https://bitovi-community.slack.com/messages/CFC80DU5B">#donejs channel</a>) or the <a href="https://forums.bitovi.com">forums</a>!</p>

			</section>
			
			

			

			

		
		</article>
		

	
		</div>
	</div>
	

<survey-ad>
  <button aria-label="Close" class="close" type="button">
    <span aria-hidden="true">&times;</span>
  </button>
  <a href="https://donejs.com/survey.html">
    Help us improve DoneJS by taking our community survey
  </a>
</survey-ad>


	
	<footer>
		<div class="container">
			<div class="row">
				<div class="col-xs-12 col-sm-8">
					<div class="col-xs-1 footer-brand">
						<a href="/"><img src="static/img/donejs-logo-final-02.svg"></a>
					</div>

					<ul class="footer-nav-main list-stacked">
						<li>
							<a href="/">HOME</a>
						</li>
						<li>
							<a href="./Features.html">FEATURES</a>
						</li>
						<li>
							<a href="./About.html">ABOUT</a>
						</li>
						<li>
							<a href="./Apis.html">APIS</a>
						</li>
						<li>
							<a href="./Guides.html">GUIDES</a>
						</li>
						<li>
							<a href="./community.html">COMMUNITY</a>
						</li>
					</ul>
				</div>
				<div class="col-xs-12 col-sm-4">
					<ul class="footer-nav-social list-stacked">
						<li>
							<a href="https://github.com/donejs">
								<img class="footer-social-icon" src="static/img/icon-github-white.svg" alt="Github">
							</a>
						</li>
						<li>
							<a href="https://twitter.com/donejs">
								<img class="footer-social-icon" src="static/img/icon-twitter-white.svg" alt="Twitter">
							</a>
						</li>
						<li>
							<a href="https://plus.google.com/+Bitovi/posts">
								<img class="footer-social-icon" src="static/img/icon-googleplus-white.svg" alt="Google+">
							</a>
						</li>
						<li>
							<a href="https://www.youtube.com/channel/UCEnTQUfJi0L6l7g8IRuaVkg">
								<img class="footer-social-icon" src="static/img/icon-youtube-white.svg" alt="YouTube">
							</a>
						</li>
					</ul>
				</div>
				<div class="clear"></div>
				<div class="footer-copyright col-sm-12">
					&copy; <a href="https://www.bitovi.com/">2015-2019 Bitovi, Inc.</a>
				</div>
			</div>
		</div>
	</footer>
	

	<script type="text/javascript">
		var docObject = {"src":{"path":"docs/guides/place-my-order.md"},"description":"In this guide you will learn about all of [DoneJS' features](./Features.html) by creating, testing, documenting, building and deploying [place-my-order.com](http://www.place-my-order.com), a restaurant menu and ordering application. The final result will look like this: \n\n<img src=\"static/img/place-my-order.png\" srcset=\"static/img/place-my-order.png 1x, static/img/place-my-order-2x.png 2x\">\n\n\nAfter the initial application setup, which includes a server that hosts and pre-renders the application, we will create several custom elements and bring them together using the application state and routes. Then we will learn how to retrieve data from the server using a RESTful API.\n\nAfter that we will talk about what a view model is and how to identify, implement and test its functionality. Once we have unit tests running in the browser, we will automate running them locally from the command line and also on a continuous integration server. In the subsequent chapters, we will show how to easily import other modules into our application and how to set up a real-time connection.\n\nFinally, we will describe how to build and deploy our application to the web, as a desktop application with Electron, and as a mobile app with Cordova.\n\n\n","name":"place-my-order","title":"In-depth guide","type":"page","parent":"Guides","hideSidebar":true,"outline":{"depth":2,"tag":"ol"},"comment":" ","pathToRoot":".."};
	</script>

	
		<script type="text/javascript">
		  steal = {
		    instantiated: {
		      "bundles/bit-docs-site/static.css!$css" : null
		    }
		  };
		</script>
		<script
			data-main="bit-docs-site/static"
			src="./static/steal.production.js"
		>
		</script>
	

	<script>
	 (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	 (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	 m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	 })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	 ga('create', 'UA-2302003-14', 'auto');
	 ga('send', 'pageview');
	</script>
</body>
</html>
